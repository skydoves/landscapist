{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>\ud83c\udf3b Landscapist is a highly optimized, pluggable Jetpack Compose image loading solution, offering seamless network image fetching and display capabilities using Glide, Coil, and Fresco. </p> <p>This library supports tracing image loading states, enabling you to compose custom implementations with ease. It also provides a range of valuable animations, including crossfades, blur transformations, and circular reveals, enhancing the visual appeal of your images. </p> <p>Additionally, Landscapist offers the flexibility to configure and attach image-loading behaviors effortlessly using image plugins, allowing for swift and efficient customization. </p>"},{"location":"#why-landscapist","title":"Why Landscapist?","text":"<p>Landscapist is a thoughtfully designed solution, meticulously crafted to optimize image loading performance in Jetpack Compose. The majority of its composable functions are marked as Restartable and Skippable, signifying significant improvements in recomposition performance, as measured by the Compose compiler metrics. Additionally, the library's performance has been enhanced further through the implementation of Baseline Profiles.</p> <p>Landscapist offers extensive support for pluggable features, making it a highly flexible and versatile library. Some of its remarkable capabilities include ImageOptions,  listening image state changes, and the ability to create custom composables. It even offers seamless integration with Android Studio for previewing, making development more efficient.</p> <p>Furthermore, Landscapist provides various features such as ImageComponent and ImagePlugin, placeholder, animations (circular reveal, crossfade), transformation (blur), and palette support. With such a rich set of functionalities, Landscapist offers an unparalleled experience in image handling within Jetpack Compose.</p> <p>See the Compose compiler metrics for Landscapist</p> <p></p> <p>Additionally, Landscapist has been featured on the Google Play SDK Console after meeting the following criteria: it is used by 100+ apps and has accumulated over 100 million app installs, according to Google Play\u2019s data.</p> <p>All issues raised by this library can be reported securely and safely. Impressively, Landscapist has reported zero crashes over the past year.</p> <p>See the Google Play SDK Console Crash Reports for Landscapist</p> <p></p>"},{"location":"#whos-using-landscapist","title":"Who's using Landscapist?","text":"<p>Landscapist is experiencing incredible success, with over +700,000 downloads every month from users worldwide! \ud83d\ude80 </p> <p>This impressive global reach reflects the trust and popularity of Landscapist among developers and demonstrates its significant impact on the Jetpack Compose image loading ecosystem.</p> <p></p> <p>Especially, the global products below are using Landscapist.</p> Product Logo License X for Android License Azar for Android License KakaoBank License Hakuna: Live Streams and Chat License MISTPLAY: Play to earn rewards License Faire for Android License Stream Chat &amp; Video SDKs for Android License"},{"location":"animation/","title":"Animation","text":"<p>The landscapist-animation package offers a set of valuable image plugins related to animations, including crossfade and circular reveal animations. </p> <p>To utilize these animation supports, simply add the following dependency:</p> <p></p> GroovyKTS <pre><code>dependencies {\n    implementation \"com.github.skydoves:landscapist-animation:$version\"\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:landscapist-animation:$version\")\n}\n</code></pre>"},{"location":"animation/#crossfade-animation","title":"Crossfade Animation","text":"<p>You can effortlessly implement the crossfade animation while displaying images using the CrossfadePlugin, as shown in the example below:</p> GlideCoilFresco <pre><code>GlideImage(\n  component = rememberImageComponent {\n      +CrossfadePlugin(\n        duration = 550\n      )\n  },\n  ..\n)\n</code></pre> <pre><code>CoilImage(\n  component = rememberImageComponent {\n      +CrossfadePlugin(\n        duration = 550\n      )\n  },\n  ..\n)\n</code></pre> <pre><code>FrescoImage(\n  component = rememberImageComponent {\n      +CrossfadePlugin(\n        duration = 550\n      )\n  },\n  ..\n)\n</code></pre> <p>By using the <code>CrossfadePlugin</code>, you can achieve smooth and visually pleasing image transitions that gracefully fade from one image to another. This animation effect adds a touch of elegance to your app and enhances the overall user experience while displaying images.</p>"},{"location":"animation/#circular-reveal-animation","title":"Circular Reveal Animation","text":"<p>You can seamlessly implement the circular reveal animation while displaying images using the <code>CircularRevealPlugin</code>, as demonstrated below:</p> GlideCoilFresco <pre><code>GlideImage(\n  component = rememberImageComponent {\n      +CircularRevealPlugin(\n        duration = 350\n      )\n  },\n  ..\n)\n</code></pre> <pre><code>CoilImage(\n  component = rememberImageComponent {\n      +CircularRevealPlugin(\n        duration = 350\n      )\n  },\n  ..\n)\n</code></pre> <pre><code>FrescoImage(\n  component = rememberImageComponent {\n      +CircularRevealPlugin(\n        duration = 350\n      )\n  },\n)\n</code></pre> <p>The <code>CircularRevealPlugin</code> allows you to create captivating image transitions that emanate from a circular shape, adding a visually engaging effect to your app. This animation enhances the user experience and provides a delightful way to showcase images within your application.</p>"},{"location":"animation/#preview","title":"Preview","text":"Circular Reveal Crossfade"},{"location":"bom/","title":"BOM","text":"<p>The Landscapist Bill of Materials (BOM) simplifies the management of all Landscapist library versions. By specifying only the BOM's version, you can effortlessly manage the versions of all Landscapist libraries used in your project.</p> <p></p> GroovyKTS <pre><code>dependencies {\n    // Import the landscapist BOM\n    implementation \"com.github.skydoves:landscapist-bom:$version\"\n\n    // Import landscapist libraries\n    implementation \"com.github.skydoves:landscapist-glide\"\n    implementation \"com.github.skydoves:landscapist-coil\"\n    implementation \"com.github.skydoves:landscapist-fresco\"\n\n    implementation \"com.github.skydoves:landscapist-animation\"\n    implementation \"com.github.skydoves:landscapist-placeholder\"\n    implementation \"com.github.skydoves:landscapist-palette\"\n    implementation \"com.github.skydoves:landscapist-transformation\"\n    implementation \"com.github.skydoves:landscapist-zoomable\"\n}\n</code></pre> <pre><code>dependencies {\n    // Import the landscapist BOM\n    implementation(\"com.github.skydoves:landscapist-bom:$version\")\n\n    // Import landscapist libraries\n    implementation(\"com.github.skydoves:landscapist-glide\")\n    implementation(\"com.github.skydoves:landscapist-coil\")\n    implementation(\"com.github.skydoves:landscapist-fresco\")\n\n    implementation(\"com.github.skydoves:landscapist-animation\")\n    implementation(\"com.github.skydoves:landscapist-placeholder\")\n    implementation(\"com.github.skydoves:landscapist-palette\")\n    implementation(\"com.github.skydoves:landscapist-transformation\")\n    implementation(\"com.github.skydoves:landscapist-zoomable\")\n}\n</code></pre> <p>This ensures a streamlined and efficient development process, as you can easily keep track of library versions and ensure compatibility across your Landscapist dependencies. </p>"},{"location":"coil3/","title":"Coil3 (KMP)","text":"Landscapist Coil3 <p>Add the dependency below to your module's <code>build.gradle</code> file:</p> GroovyKTS <pre><code>dependencies {\n    implementation \"com.github.skydoves:landscapist-coil3:$version\"\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:landscapist-coil3:$version\")\n}\n</code></pre> <p>If you're targeting on Kotlin Multiplatform, add the dependency below to your module's <code>build.gradle.kts</code> file:</p> <pre><code>sourceSets {\n    val commonMain by getting {\n        dependencies {\n            implementation(\"com.github.skydoves:landscapist-coil3:$version\")\n        }\n    }\n}\n</code></pre> <p>The <code>coil3-landscapist</code> package functions identically to the <code>coil-landscapist</code> package, with the key distinction being its focus on Kotlin Multiplatform. This enables the use of Coil3 across various platforms, including Android, iOS, and Desktop (JVM), facilitating a unified image loading experience across different environments.</p> <p>Note</p> <p>Please make sure your project uses the same Jetpack Compose version on the release page.</p>"},{"location":"coil3/#coilimage","title":"CoilImage","text":"<p>You can load images by using the <code>CoilImage</code> composable function as the following example below:</p> <pre><code>CoilImage(\n  imageModel = { imageUrl }, // loading a network image or local resource using an URL.\n  imageOptions = ImageOptions(\n    contentScale = ContentScale.Crop,\n    alignment = Alignment.Center\n  )\n)\n</code></pre>"},{"location":"coil3/#compose-metrics","title":"Compose Metrics","text":"<p>According to the Compose Compiler Metrics, the <code>CoilImage</code> Composable function is marked as Restartable and Skippable. This means you don't have to worry about performance issues related to re-rendering or re-fetching problems that can occur during recomposition. The Composable function's restartable and skippable nature ensures that the necessary actions are taken to optimize rendering, making it more efficient and seamless.</p> <p></p>"},{"location":"custom-composable/","title":"Custom Composable","text":"<p>Landscapist offers a powerful way to load images using your custom Composable functions. This capability allows you to tailor your own loading placeholders, success images, or fallbacks for handling loading failures. With such flexibility, you can create a personalized and seamless image loading experience tailored to your specific app's needs.</p>"},{"location":"custom-composable/#build-your-own-composable","title":"Build Your Own Composable","text":"<p>You can execute your own composable functions based on the three image states below:</p> <ul> <li>loading: Executes while the image is being loaded.</li> <li>success: Executes upon successful image loading.</li> <li>failure: Executes when there is a failure to load the image (e.g., network error, incorrect destination).</li> </ul> GlideCoilFresco <pre><code>GlideImage(\n  // displays an indicator while loading an image.\n  loading = {\n    Box(modifier = Modifier.matchParentSize()) {\n      CircularProgressIndicator(\n        modifier = Modifier.align(Alignment.Center)\n     ) \n    }\n  },\n  // displays an error fallback if fails to load an image.\n  failure = {\n    Text(text = \"image request failed.\")\n },\n  ..\n)\n</code></pre> <pre><code>CoilImage(\n  // displays an indicator while loading an image.\n  loading = {\n    Box(modifier = Modifier.matchParentSize()) {\n      CircularProgressIndicator(\n        modifier = Modifier.align(Alignment.Center)\n     ) \n    }\n  },\n  // displays an error fallback if fails to load an image.\n  failure = {\n    Text(text = \"image request failed.\")\n },\n  ..\n)\n</code></pre> <pre><code>FrescoImage(\n  // displays an indicator while loading an image.\n  loading = {\n    Box(modifier = Modifier.matchParentSize()) {\n      CircularProgressIndicator(\n        modifier = Modifier.align(Alignment.Center)\n     ) \n    }\n  },\n  // displays an error fallback if fails to load an image.\n  failure = {\n    Text(text = \"image request failed.\")\n },\n  ..\n)\n</code></pre> <p>With the above custom loading composable sample, you'll see the result below:</p> <p></p>"},{"location":"custom-composable/#render-your-own-image-composable","title":"Render Your Own Image Composable","text":"<p>You can also render your own Composable function with the success image state.</p> GlideCoilFresco <pre><code>GlideImage(\n  success = { imageState -&gt;\n    imageState.imageBitmap?.let {\n      Image(\n        bitmap = it,\n        modifier = Modifier.size(128.dp) // draw a resized image.\n      )\n    }\n  },\n  ..\n)\n</code></pre> <pre><code>CoilImage(\n  success = { imageState -&gt;\n    imageState.imageBitmap?.let {\n      Image(\n        bitmap = it,\n        modifier = Modifier.size(128.dp) // draw a resized image.\n      )\n    }\n  },\n  ..\n)\n</code></pre> <pre><code>FrescoImage(\n  success = { imageState -&gt;\n    imageState.imageBitmap?.let {\n      Image(\n        bitmap = it,\n        modifier = Modifier.size(128.dp) // draw a resized image.\n      )\n    }\n  },\n  ..\n)\n</code></pre> <p>As you can see in the above example, you're able to render your image composable inside the <code>success</code> lambda parameter, which provides the image state and painter.</p>"},{"location":"image-component-and-plugin/","title":"ImageComponent and ImagePlugin","text":"<p>One of the most versatile fatures of Landscapist is the <code>ImageComponent</code> and <code>ImagePlugin</code>:</p> <ul> <li>ImageComponent: The <code>ImageComponent</code> is a flexible interface that acts as a container for a collection of <code>ImagePlugins</code>.</li> <li>ImagePlugin: The <code>ImagePlugin</code> is an executable and pluggable Compose interface, triggered based on specific image states.</li> </ul> <p>With Landscapist, you have the flexibility to compose supported image plugins, or you can even implement your own custom image plugin that will be executed based on the image loading state. This powerful feature empowers you to tailor the image loading behavior according to your specific needs and preferences.</p> <ul> <li>PainterPlugin: A pinter plugin interface to be composed with the given <code>Painter</code>.</li> <li>LoadingStatePlugin: A pluggable state plugin that will be composed while the state is <code>ImageLoadState.Loading</code>.</li> <li>SuccessStatePlugin: A pluggable state plugin that will be composed when the state is <code>ImageLoadState.Success</code>.</li> <li>FailureStatePlugin: A pluggable state plugin that will be composed when the state is <code>ImageLoadState.Failure</code>.</li> </ul> <p>Whether you choose from the existing plugins or create your own, Landscapist offers a seamless and customizable image loading experience for your app.</p> <p>As an example, you can implement your own LoadingStatePlugin that will be composed specifically while loading an image, as demonstrated below:</p> <pre><code>data class LoadingPlugin(val source: Any?) : ImagePlugin.LoadingStatePlugin {\n\n  // this composable function will be executed while loading an image.\n  @Composable\n  override fun compose(\n    modifier: Modifier,\n    imageOptions: ImageOptions,\n    executor: @Composable (IntSize) -&gt; Unit,\n  ): ImagePlugin = apply {\n    if (source != null &amp;&amp; imageOptions != null) {\n      ImageBySource(\n        source = source,\n        modifier = modifier,\n        alignment = imageOptions.alignment,\n        contentDescription = imageOptions.contentDescription,\n        contentScale = imageOptions.contentScale,\n        colorFilter = imageOptions.colorFilter,\n        alpha = imageOptions.alpha\n      )\n    }\n  }\n}\n</code></pre> <p>By creating a custom <code>LoadingStatePlugin</code>, you can define unique behavior tailored to the loading state of the image. This gives you the freedom to handle loading scenarios in a way that best suits your application's requirements.</p> <p>Now you can add your own image plugin into the image component like so:</p> GlideCoilFresco <pre><code>GlideImage(\n    component = rememberImageComponent {\n        add(CircularRevealPlugin())\n        add(LoadingPlugin(source))\n    },\n    ..\n)\n</code></pre> <pre><code>CoilImage(\n    component = rememberImageComponent {\n        add(CircularRevealPlugin())\n        add(LoadingPlugin(source))\n    },\n    ..\n)\n</code></pre> <pre><code>FrescoImage(\n    component = rememberImageComponent {\n        add(CircularRevealPlugin())\n        add(LoadingPlugin(source))\n    },\n    ..\n)\n</code></pre> <p>or you can just add plugins by using the + expression like the below:</p> GlideCoilFresco <pre><code>GlideImage(\n    component = rememberImageComponent {\n        +CircularRevealPlugin()\n        +LoadingPlugin(source)\n    },\n    ..\n)\n</code></pre> <pre><code>CoilImage(\n    component = rememberImageComponent {\n        +CircularRevealPlugin()\n        +LoadingPlugin(source)\n    },\n    ..\n)\n</code></pre> <pre><code>FrescoImage(\n    component = rememberImageComponent {\n        +CircularRevealPlugin()\n        +LoadingPlugin(source)\n    },\n    ..\n)\n</code></pre>"},{"location":"image-component-and-plugin/#localimagecomponent","title":"LocalImageComponent","text":"<p>You can easily share the same <code>ImageComponent</code> instance throughout your composable hierarchy by utilizing the <code>imageComponent</code> extension and <code>LocalImageComponent</code>, as demonstrated below:</p> <pre><code>val component = imageComponent {\n  +CrossfadePlugin()\n  +PalettePlugin()\n}\n\nCompositionLocalProvider(LocalImageComponent provides component) {\n\n  val imageComponent = LocalImageComponent.current\n\n  GlideImage(\n    component = imageComponent,\n    ..\n  )\n}\n</code></pre> <p>By using <code>LocalImageComponent</code>, you can ensure that the same <code>ImageComponent</code> instance is accessible within the entire composable hierarchy, enabling seamless sharing of the image configuration across various composables. This makes it effortless to maintain consistency and manage image handling efficiently throughout your app.</p>"},{"location":"image-options/","title":"Image Options","text":"<p>You can provide image options to your Landscapist composable functions by passing an <code>ImageOptions</code> instance, as demonstrated in the code below:</p> GlideCoilFresco <pre><code>GlideImage(\n  imageOptions = ImageOptions(\n    contentScale = ContentScale.Crop,\n    alignment = Alignment.Center,\n    contentDescription = \"profile image\",\n    colorFilter = null,\n    alpha = 1f,\n    tag = \"user profile image\"\n  ),\n  ..\n)\n</code></pre> <pre><code>CoilImage(\n  imageOptions = ImageOptions(\n    contentScale = ContentScale.Crop,\n    alignment = Alignment.Center,\n    contentDescription = \"profile image\",\n    colorFilter = null,\n    alpha = 1f,\n    tag = \"user profile image\"\n  ),\n  ..\n)    \n</code></pre> <pre><code>FrescoImage(\n  imageOptions = ImageOptions(\n    contentScale = ContentScale.Crop,\n    alignment = Alignment.Center,\n    contentDescription = \"profile image\",\n    colorFilter = null,\n    alpha = 1f,\n    tag = \"user profile image\"\n  ),\n  ..\n)\n</code></pre>"},{"location":"image-options/#adjust-requesting-size","title":"Adjust Requesting Size","text":"<p>To prevent potential Out of Memory Exceptions when loading large-sized images, you can set the explicit request size of your image using the <code>requestSize</code> property, as shown below:</p> <pre><code>GlideImage(\n  ..,\n  imageOptions = ImageOptions(requestSize = IntSize(800, 600)),\n)\n</code></pre> <p>Landscapist will fetch the image with the explicit size from the network first, ensuring the image is rendered with the appropriate dimensions without consuming excessive memory. If you don't specify a specific <code>requestSize</code> parameter, the image will be automatically adjusted based on its original dimensions.</p>"},{"location":"image-state/","title":"Image States","text":"<p>The image states indicate the current state of the image, which includes loading from the network, rendering success, or encountering failure. Based on these states, you have the flexibility to execute your own functions and implement custom behavior accordingly.</p>"},{"location":"image-state/#listening-image-state-changes","title":"Listening image state changes","text":"<p>You can listen for image state changes by providing the onImageStateChanged parameter to your image composable functions, as illustrated below:</p> GlideCoilFresco <pre><code>GlideImage(\n  onImageStateChanged = {\n    when (it) {\n       GlideImageState.None -&gt; ..\n       GlideImageState.Loading -&gt; ..\n       is GlideImageState.Success -&gt; ..\n       is GlideImageState.Failure -&gt; ..\n    }\n  },\n  ..\n)\n</code></pre> <pre><code>CoilImage(\n  onImageStateChanged = {\n    when (it) {\n       CoilImageState.None -&gt; ..\n       CoilImageState.Loading -&gt; ..\n       is CoilImageState.Success -&gt; ..\n       is CoilImageState.Failure -&gt; ..\n    }\n  },\n  ..\n)\n</code></pre> <pre><code>FrescoImage(\n  onImageStateChanged = {\n    when (it) {\n       FrescoImageState.None -&gt; ..\n       FrescoImageState.Loading -&gt; ..\n       is FrescoImageState.Success -&gt; ..\n       is FrescoImageState.Failure -&gt; ..\n    }\n  },\n  ..\n)\n</code></pre>"},{"location":"image-state/#remember-image-states","title":"Remember Image States","text":"<p>Landscapist offers valuable functions to remember image states within your Composable function and utilize them outside of the <code>onImageStateChanged</code> lambda scope. To achieve this, you can utilize the <code>remember_ImageState()</code> function as demonstrated in the sample below:</p> GlideCoilFresco <pre><code>var glideImageState by rememberGlideImageState()\n\nGlideImage(\n  onImageStateChanged = {\n    glideImageState = it\n  },\n  ..\n)\n</code></pre> <pre><code>var coilImageState by rememberCoilImageState()\n\nCoilImage(\n  onImageStateChanged = {\n    coilImageState = it\n  },\n  ..\n)\n</code></pre> <pre><code>var frescoImageState by rememberFrescoImageState()\n\nFrescoImage(\n  onImageStateChanged = {\n    frescoImageState = it\n  },\n  ..\n)\n</code></pre>"},{"location":"image-state/#datasource","title":"DataSource","text":"<p>You can trace the origin of the image source from the succees image state with the <code>DataSource</code> parameter. The <code>DataSource</code> encompasses the following source origins below:</p> <ul> <li>Memory: Represents an in-memory data source or cache (e.g. bitmap, ByteBuffer).</li> <li>Disk: Represents a disk-based data source (e.g. drawable resource, or File).</li> <li>Network: Represents a network-based data source.</li> <li>Unknown: Represents an unknown data source.</li> </ul>"},{"location":"palette/","title":"Palette","text":"<p>The <code>landscapist-palette</code> package offers a set of valuable image plugins related to the palette, including extracting primary color sets.</p> <p>To utilize these palette supports, simply add the following dependency:</p> <p></p> GroovyKTS <pre><code>dependencies {\n    implementation \"com.github.skydoves:landscapist-palette:$version\"\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:landscapist-palette:$version\")\n}\n</code></pre> <p>You can extract primary (theme) color profiles with <code>PalettePlugin</code>. You can check out Extract color profiles to see what kinds of colors can be extracted.</p> GlideCoilFresco <pre><code>var palette by rememberPaletteState(null)\n\nGlideImage(\n  component = rememberImageComponent {\n      +PalettePlugin { palette = it }\n  },\n  ..\n)\n\nCrossfade(\n    targetState = palette,\n    modifier = Modifier\n        .padding(horizontal = 8.dp)\n        .size(45.dp)\n) {\n  Box(\n    modifier = Modifier\n      .background(color = Color(it?.lightVibrantSwatch?.rgb ?: 0))\n      .fillMaxSize()\n  )\n}\n</code></pre> <pre><code>var palette by rememberPaletteState(null)\n\nCoilImage(\n  component = rememberImageComponent {\n      +PalettePlugin { palette = it }\n  },\n  ..\n)\n\nCrossfade(\n    targetState = palette,\n    modifier = Modifier\n        .padding(horizontal = 8.dp)\n        .size(45.dp)\n) {\n  Box(\n    modifier = Modifier\n      .background(color = Color(it?.lightVibrantSwatch?.rgb ?: 0))\n      .fillMaxSize()\n  )\n}\n</code></pre> <pre><code>var palette by rememberPaletteState(null)\n\nFrescoImage(\n  component = rememberImageComponent {\n      +PalettePlugin { palette = it }\n  },\n  ..\n)\n\nCrossfade(\n    targetState = palette,\n    modifier = Modifier\n        .padding(horizontal = 8.dp)\n        .size(45.dp)\n) {\n  Box(\n    modifier = Modifier\n      .background(color = Color(it?.lightVibrantSwatch?.rgb ?: 0))\n      .fillMaxSize()\n  )\n}\n</code></pre> <p>You can also customize attributes of <code>PalettePlugin</code> like the example below:</p> GlideCoilFresco <pre><code>var palette by rememberPaletteState(null)\n\nGlideImage(\n  component = rememberImageComponent {\n    +PalettePlugin(\n        imageModel = poster.image,\n        useCache = true, // use cache strategies for the same image model.\n        interceptor = {\n            it.addFilter { rgb, hsl -&gt;\n            // here edit to add the filter colors.\n            false\n            }\n        },\n        paletteLoadedListener = {\n            palette = it\n        }\n    )\n  },\n  ..\n)\n\nCrossfade(\n    targetState = palette,\n    modifier = Modifier\n        .padding(horizontal = 8.dp)\n        .size(45.dp)\n) {\n  Box(\n    modifier = Modifier\n      .background(color = Color(it?.lightVibrantSwatch?.rgb ?: 0))\n      .fillMaxSize()\n  )\n}\n</code></pre> <pre><code>var palette by rememberPaletteState(null)\n\nCoilImage(\n  component = rememberImageComponent {\n    +PalettePlugin(\n        imageModel = poster.image,\n        useCache = true, // use cache strategies for the same image model.\n        interceptor = {\n            it.addFilter { rgb, hsl -&gt;\n            // here edit to add the filter colors.\n            false\n            }\n        },\n        paletteLoadedListener = {\n            palette = it\n        }\n    )\n  },\n  ..\n)\n\nCrossfade(\n    targetState = palette,\n    modifier = Modifier\n        .padding(horizontal = 8.dp)\n        .size(45.dp)\n) {\n  Box(\n    modifier = Modifier\n      .background(color = Color(it?.lightVibrantSwatch?.rgb ?: 0))\n      .fillMaxSize()\n  )\n}\n</code></pre> <pre><code>var palette by rememberPaletteState(null)\n\nFrescoImage(\n  component = rememberImageComponent {\n    +PalettePlugin(\n        imageModel = poster.image,\n        useCache = true, // use cache strategies for the same image model.\n        interceptor = {\n            it.addFilter { rgb, hsl -&gt;\n            // here edit to add the filter colors.\n            false\n            }\n        },\n        paletteLoadedListener = {\n            palette = it\n        }\n    )\n  },\n  ..\n)\n\nCrossfade(\n    targetState = palette,\n    modifier = Modifier\n        .padding(horizontal = 8.dp)\n        .size(45.dp)\n) {\n  Box(\n    modifier = Modifier\n      .background(color = Color(it?.lightVibrantSwatch?.rgb ?: 0))\n      .fillMaxSize()\n  )\n}\n</code></pre>"},{"location":"palette/#preview","title":"Preview","text":""},{"location":"placeholder/","title":"Placeholder","text":"<p>The <code>landscapist-placeholder</code> package offers a rich selection of image plugins for implementing placeholders, including loading and failure placeholder support, as well as shimmering animations.</p> <p>To utilize these placeholder supports, simply add the following dependency:</p> <p></p> GroovyKTS <pre><code>dependencies {\n    implementation \"com.github.skydoves:landscapist-placeholder:$version\"\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:landscapist-placeholder:$version\")\n}\n</code></pre>"},{"location":"placeholder/#placeholderplugin","title":"PlaceholderPlugin","text":"<p>You have the ability to display your custom placeholders while loading an image or in case of a loading failure by using the <code>PlaceholderPlugin.Loading</code> <code>and PlaceholderPlugin.Failure</code> respectively.</p> GlideCoilFresco <pre><code>GlideImage(\n  component = rememberImageComponent {\n      +PlaceholderPlugin.Loading(painterResource(id = R.drawable.placeholder_loading))\n      +PlaceholderPlugin.Failure(painterResource(id = R.drawable.placeholder_failure))\n  },\n  ..\n)\n</code></pre> <pre><code>CoilImage(\n  component = rememberImageComponent {\n      +PlaceholderPlugin.Loading(painterResource(id = R.drawable.placeholder_loading))\n      +PlaceholderPlugin.Failure(painterResource(id = R.drawable.placeholder_failure))\n  },\n  ..\n)\n</code></pre> <pre><code>FrescoImage(\n  component = rememberImageComponent {\n      +PlaceholderPlugin.Loading(painterResource(id = R.drawable.placeholder_loading))\n      +PlaceholderPlugin.Failure(painterResource(id = R.drawable.placeholder_failure))\n  },\n  ..\n)\n</code></pre> <p>Note</p> <p>The source should be one of <code>ImageBitmap</code>, <code>ImageVector</code>, or <code>Painter</code>.</p>"},{"location":"placeholder/#shimmerplugin","title":"ShimmerPlugin","text":"<p>You can implement a shimmering effect while loading an image by using the <code>ShimmerPlugin</code>, as shown in the example below:</p> GlideCoilFresco <pre><code>GlideImage(\n    component = rememberImageComponent {\n      // displays a shimmering effect when loading an image.\n      +ShimmerPlugin(\n        Shimmer.Flash(\n          baseColor = Color.White,\n          highlightColor = Color.LightGray,\n        )\n      )\n    },\n    ..\n)\n</code></pre> <pre><code>CoilImage(\n    component = rememberImageComponent {\n      // displays a shimmering effect when loading an image.\n      +ShimmerPlugin(\n        Shimmer.Flash(\n          baseColor = Color.White,\n          highlightColor = Color.LightGray,\n        )\n      )\n    },\n    ..\n)\n</code></pre> <pre><code>FrescoImage(\n    component = rememberImageComponent {\n      // displays a shimmering effect when loading an image.\n      +ShimmerPlugin(\n        Shimmer.Flash(\n          baseColor = Color.White,\n          highlightColor = Color.LightGray,\n        )\n      )\n    },\n    ..\n)\n</code></pre> <p>After building the above sample, you'll see the shimmering effect in the result below:</p> <p></p> <p><code>Shimmer</code> sealed class provides following the three different types: <code>Resonate</code>, <code>Fade</code>, and <code>Flash</code>.</p> Resonate Fade Flash"},{"location":"placeholder/#thumbnailplugin","title":"ThumbnailPlugin","text":"<p>Landscapist supports the thumbnail feature, enabling pre-loading and displaying small-sized images while loading the original image. This approach creates the illusion of faster image loading and delivers a natural loading effect to users. To showcase the thumbnail, simply add the image plugin to your image component, as illustrated in the example below:</p> GlideCoilFresco <pre><code>GlideImage(\n    component = rememberImageComponent {\n        +ThumbnailPlugin() \n    },\n    ..\n)\n</code></pre> <pre><code>CoilImage(\n    component = rememberImageComponent {\n        +ThumbnailPlugin() \n    },\n    ..\n)\n</code></pre> <pre><code>FrescoImage(\n    component = rememberImageComponent {\n        +ThumbnailPlugin() \n    },\n    ..\n)\n</code></pre> <p>You can also adjust the request sizes by giving the <code>requestSize</code> parameter:</p> GlideCoilFresco <pre><code>GlideImage(\n    component = rememberImageComponent {\n        +ThumbnailPlugin(IntSize(30 ,30))\n    },\n    ..\n)\n</code></pre> <pre><code>CoilImage(\n    component = rememberImageComponent {\n        +ThumbnailPlugin(IntSize(30 ,30))\n    },\n    ..\n)\n</code></pre> <pre><code>FrescoImage(\n    component = rememberImageComponent {\n        +ThumbnailPlugin(IntSize(30 ,30))\n    },\n    ..\n)\n</code></pre> <p>Note</p> <p>Using a small request size on the thumbnail plugin is highly recommended to expedite the pre-loading images process. By specifying a smaller request size, you ensure that the pre-loaded images load faster, optimizing the user experience during image loading and achieving smoother transitions to display the original images.</p> <p>After building the above sample, you'll see the thumbnail while loading an image in the result below:</p> <p></p>"},{"location":"preview/","title":"Preview on Android Studio","text":"<p>Android Studio's Composable Preview feature is an incredibly powerful tool that allows you to develop and preview a specific part of your Composable without the need to build the entire project.</p> <p>The versatility of Landscapist extends to supporting preview mode for each image library, including Glide, Coil, and Fresco. You can conveniently showcase preview images directly within your editor using the previewPlaceholder parameter, as demonstrated below:</p> GlideCoilFresco <pre><code>GlideImage(\n  previewPlaceholder = painterResource(id = R.drawable.poster),\n  ..\n)\n</code></pre> <pre><code>CoilImage(\n  previewPlaceholder = painterResource(id = R.drawable.poster),\n  ..\n)\n</code></pre> <pre><code>FrescoImage(\n  previewPlaceholder = painterResource(id = R.drawable.poster),\n  ..\n)\n</code></pre> <p>This feature streamlines your development process, providing a visual representation of the image before building the entire project, saving valuable time and effort.</p> <p>Now, you can build your preview composable like so:</p> <pre><code>@Composable\nprivate fun GlideImagePreview() {\n    GlideImage(\n      previewPlaceholder = painterResource(id = R.drawable.poster),\n      ..\n    )\n}\n</code></pre> <p>Once you compile your preview function, you will see the result displayed below in your Android Studio:</p> <p></p>"},{"location":"snapshots-with-paparazzi/","title":"Snapshots With Paparazzi","text":"<p>Paparazzi empowers you to capture snapshot images of your Composable functions without the need to run them on physical devices. With Paparazzi, you can easily take proper snapshot images of your Composables, providing a visual representation of your app's UI.</p> <p>By utilizing Paparazzi, you can efficiently validate your app's UI states, ensuring consistent and visually appealing designs.</p> <pre><code>paparazzi.snapshot {\n  CompositionLocalProvider(LocalInspectionMode provides true) {\n\n    GlideImage(\n      modifier = Modifier.fillMaxSize(),\n      previewPlaceholder = painterResource(id = R.drawable.placeholder),\n      ..\n    )\n  }\n}\n</code></pre>"},{"location":"sponsor/","title":"Sponsor \ud83e\ude77","text":"<p>Landscapist has been skillfully crafted and maintained by skydoves (Jaewoong Eum) since the early days of Compose when it was in its alpha version. As an early adopter of Compose, skydoves recognized the potential of this modern toolkit and set out to develop Landscapist, ensuring seamless and efficient image loading capabilities within Compose-based projects.</p> <p>Jaewoong has created and contributed more than +70 open-source projects and libraries related to Android and Kotlin. With over his open-source projects and libraries, his work has left a significant impact on the development landscape. These projects have been widely embraced by millions of projects, software engineers, and end-users worldwide, with prominent organizations like PayPal, Twitter, Wikipedia, and others benefiting from their creations.</p> <p>If your team or personal projects have benefited from reduced development costs by using this library, you can show your appreciation and support by sponsoring him through the links below:</p> <ul> <li>GitHub Sponsor</li> <li>PayPal</li> </ul> <p>Sponsoring helps sustain the continuous development and improvement of the library, ensuring that it remains a valuable resource for the community. Your contribution not only shows gratitude but also contributes to the growth and success of open-source projects like this one. Feel free to lend your support and make a positive impact on the developer's efforts.</p> <p>If you want to suggest a feature request or sponsorship collaboration, you can reach out to the author with the contacts below:</p> <ul> <li>skydoves2@gmail.com</li> <li>Twitter</li> </ul>"},{"location":"sponsor/#sponsors","title":"Sponsors","text":"<p>These are the sponsors who have supported Landscapist.</p>"},{"location":"sponsor/#rocket-sponsor","title":"\ud83d\ude80 Rocket Sponsor","text":""},{"location":"sponsor/#airplane-sponsor","title":"\u2708\ufe0f Airplane Sponsor","text":""},{"location":"sponsor/#cruise-sponsor","title":"\ud83d\udea2 Cruise Sponsor","text":""},{"location":"sponsor/#train-sponsor","title":"\ud83d\ude82 Train Sponsor","text":"<p>I truly appreciate all of our sponsors, no matter their tier, company, or any other factor!</p> <p></p>"},{"location":"transformation/","title":"Transformation","text":"<p>The <code>landscapist-transformation</code> package offers a range of valuable image transformation plugins, including the blur effect.</p> <p>To utilize these transformation supports, simply add the following dependency:</p> <p></p> GroovyKTS <pre><code>dependencies {\n    implementation \"com.github.skydoves:landscapist-transformation:$version\"\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:landscapist-transformation:$version\")\n}\n</code></pre>"},{"location":"transformation/#blurtransformationplugin","title":"BlurTransformationPlugin","text":"<p>You can effortlessly implement the blur effect using the <code>BlurTransformationPlugin</code>, as demonstrated below:</p> GlideCoilFresco <pre><code>GlideImage(\n  component = rememberImageComponent {\n    +BlurTransformationPlugin(radius = 10) // between 0 to Int.MAX_VALUE.\n },\n  ..\n)\n</code></pre> <pre><code>CoilImage(\n  component = rememberImageComponent {\n    +BlurTransformationPlugin(radius = 10) // between 0 to Int.MAX_VALUE.\n },\n  ..\n)\n</code></pre> <pre><code>FrescoImage(\n  component = rememberImageComponent {\n    +BlurTransformationPlugin(radius = 10) // between 0 to Int.MAX_VALUE.\n },\n  ..\n)\n</code></pre> <p>By incorporating the <code>BlurTransformationPlugin</code>, you can easily add a captivating blur effect to your images, enhancing their visual appeal and creating a more dynamic and immersive user experience within your app. Adjust the <code>blurRadius</code> parameter to achieve the desired level of blurriness for your images.</p> <p>Note</p> <p>Landscapist's blur transformation falls back onto a CPU-based implementation to support older API levels. So you don't need to worry about API compatibilities and performance issues.</p>"},{"location":"transformation/#preview","title":"Preview","text":""},{"location":"version-map/","title":"Version Map","text":"<p>The Landscapist utilizes varying Compose versions and JVM targets for each release. This map will assist you in ensuring compatibility and smooth integration with your project.</p> Landscapist Compose UI Jvm Target Glide Coil Fresco 2.9.5 1.11.0 (BOM 2026.01.00) 17 5.0.5 2.7.0 or 3.3.0 3.6.0 2.9.4 1.11.0 (BOM 2026.01.00) 17 5.0.5 2.7.0 or 3.3.0 3.6.0 2.9.3 1.11.0 (BOM 2026.01.00) 17 5.0.5 2.7.0 or 3.3.0 3.6.0 2.9.2 1.11.0 (BOM 2026.01.00) 17 5.0.5 2.7.0 or 3.3.0 3.6.0 2.9.1 1.11.0 (BOM 2026.01.00) 17 5.0.5 2.7.0 or 3.3.0 3.6.0 2.9.0 1.11.0 (BOM 2026.01.00) 17 5.0.5 2.7.0 or 3.3.0 3.6.0 2.8.3 1.11.0 (BOM 2026.01.00) 17 5.0.5 2.7.0 or 3.3.0 3.6.0 2.8.2 1.10.0 (BOM 2025.12.00) 17 5.0.5 2.7.0 or 3.3.0 3.6.0 2.8.1 1.10.0 (BOM 2025.12.00) 17 5.0.5 2.7.0 or 3.3.0 3.6.0 2.8.0 1.10.0 (BOM 2025.12.00) 17 5.0.5 2.7.0 or 3.3.0 3.6.0 2.7.0 1.10.0 (BOM 2025.12.00) 17 5.0.5 2.7.0 or 3.3.0 3.6.0 2.6.2 1.10.0 (BOM 2025.12.00) 17 5.0.5 2.7.0 or 3.3.0 3.6.0 2.6.1 1.9.1 (BOM 2025.09.00) 17 5.0.5 2.7.0 or 3.3.0 3.6.0 2.6.0 1.9.1 (BOM 2025.09.00) 17 5.0.5 2.7.0 or 3.3.0 3.6.0 2.5.2 1.8.3 (BOM 2025.07.00) 17 4.16.0 2.7.0 or 3.3.0 3.6.0 2.5.1 1.8.2 (BOM 2025.06.00) 11 4.16.0 2.7.0 or 3.2.0 3.6.0 2.5.0 1.8.2 (BOM 2025.06.00) 11 4.16.0 2.7.0 or 3.2.0 3.6.0 2.4.9 1.8.0 (BOM 2025.05.00) 11 4.16.0 2.7.0 or 3.2.0 3.6.0 2.4.8 1.8.0 (BOM 2025.05.00) 11 4.16.0 2.7.0 or 3.2.0 3.6.0 2.4.7 1.7.7 (BOM 2025.02.01) 11 4.16.0 2.7.0 or 3.1.0 3.6.0 2.4.6 1.7.6 (BOM 2024.12.01) 11 4.16.0 3.0.4 3.5.0 2.4.5 1.7.6 (BOM 2024.12.01) 11 4.16.0 3.0.4 3.5.0 2.4.4 1.7.5 (BOM 2024.11.00) 11 4.16.0 3.0.4 3.5.0 2.4.3 1.7.5 (BOM 2024.11.00) 11 4.16.0 3.0.3 3.3.0 2.4.2 1.7.5 (BOM 2024.10.01) 11 4.16.0 3.0.0 3.3.0 2.4.1 1.7.3 (BOM 2024.09.03) 11 4.16.0 2.7.0 3.3.0 2.4.0 1.7.3 (BOM 2024.09.03) 11 4.16.0 2.7.0 3.3.0 2.3.2 1.6.2 (BOM 2024.02.01) 11 4.16.0 2.5.0 3.1.3 2.3.1 1.6.1 (BOM 2024.02.00) 11 4.16.0 2.5.0 3.1.3 2.3.0 1.6.0 (BOM 2024.01.00) 11 4.16.0 2.5.0 3.1.3 2.2.13 1.5.4 (BOM 2023.10.01) 11 4.16.0 2.5.0 3.1.3 2.2.12 1.5.4 (BOM 2023.10.01) 11 4.16.0 2.5.0 3.1.3 2.2.11 1.5.4 (BOM 2023.10.01) 11 4.16.0 2.5.0 3.1.3 2.2.10 1.5.2 (BOM 2023.09.02) 11 4.16.0 2.4.0 3.1.0 2.2.9 1.5.1 (BOM 2023.09.00) 11 4.16.0 2.4.0 3.1.0 2.2.8 1.5.0 (BOM 2023.08.00) 11 4.16.0 2.4.0 2.6.0 2.2.7 1.5.0 (BOM 2023.08.00) 11 4.15.1 2.3.0 2.6.0 2.2.6 1.4.3 (BOM 2023.06.00) 11 4.15.1 2.3.0 2.6.0 2.2.5 1.4.3 (BOM 2023.06.00) 17 4.15.1 2.3.0 2.6.0 2.2.4 1.4.3 (BOM 2023.06.00) 17 4.15.1 2.3.0 2.6.0 2.2.3 1.4.3 (BOM 2023.06.00) 17 4.15.1 2.3.0 2.6.0 2.2.2 1.4.3 (BOM 2023.06.00) 17 4.15.1 2.3.0 2.6.0 2.2.1 1.4.3 (BOM 2023.05.01) 17 4.15.1 2.3.0 2.6.0 2.2.0 1.4.3 (BOM 2023.05.01) 17 4.15.1 2.3.0 2.6.0 2.1.13 1.4.1 (BOM 2023.04.00) 17 4.15.1 2.3.0 2.6.0 2.1.12 1.4.1 (BOM 2023.04.00) 17 4.15.1 2.3.0 2.6.0 2.1.11 1.4.1 (BOM 2023.04.00) 17 4.15.1 2.3.0 2.6.0 2.1.10 1.4.1 (BOM 2023.04.00) 17 4.15.1 2.3.0 2.6.0 2.1.9 1.4.0 (BOM 2023.03.00) 11 4.15.1 2.3.0 2.6.0 2.1.8 1.3.3 (BOM 2023.01.00) 11 4.15.1 2.2.2 2.6.0"},{"location":"zoomable/","title":"Zoomable","text":"<p>The <code>landscapist-zoomable</code> package provides a <code>ZoomablePlugin</code> that enables zoom and pan gestures for images. This plugin supports both Android and Kotlin Multiplatform (iOS, Desktop).</p> <p>To use zoomable supports, add the dependency below:</p> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:landscapist-zoomable:$version\")\n}\n</code></pre>"},{"location":"zoomable/#zoomableplugin","title":"ZoomablePlugin","text":"<p>You can implement zoom and pan gestures by adding <code>ZoomablePlugin</code> to your image component:</p> GlideCoil <pre><code>GlideImage(\n  imageModel = { imageUrl },\n  component = rememberImageComponent {\n    +ZoomablePlugin()\n  }\n)\n</code></pre> <pre><code>CoilImage(\n  imageModel = { imageUrl },\n  component = rememberImageComponent {\n    +ZoomablePlugin()\n  }\n)\n</code></pre>"},{"location":"zoomable/#zoomablestate","title":"ZoomableState","text":"<p>You can create and remember a <code>ZoomableState</code> with <code>rememberZoomableState</code> to customize the zoom behavior and access the current transformation state:</p> <pre><code>val zoomableState = rememberZoomableState(\n  config = ZoomableConfig(\n    minZoom = 1f,           // Minimum zoom scale (default: 1f)\n    maxZoom = 4f,           // Maximum zoom scale (default: 4f)\n    doubleTapZoom = 2f,     // Zoom scale on double-tap (default: 2f)\n    enableDoubleTapZoom = true,  // Enable double-tap to zoom (default: true)\n  )\n)\n\nGlideImage(\n  imageModel = { imageUrl },\n  component = rememberImageComponent {\n    +ZoomablePlugin(state = zoomableState)\n  }\n)\n\n// Access current zoom state\nval currentScale = zoomableState.transformation.scale\nval currentOffset = zoomableState.transformation.offset\n</code></pre> <p>You can also use <code>resetKey</code> parameter to automatically reset the zoom state when the image changes:</p> <pre><code>val zoomableState = rememberZoomableState(resetKey = imageUrl)\n\nGlideImage(\n  imageModel = { imageUrl },\n  component = rememberImageComponent {\n    +ZoomablePlugin(state = zoomableState)\n  }\n)\n</code></pre>"},{"location":"zoomable/#zoomableconfig-options","title":"ZoomableConfig Options","text":"Parameter Type Default Description <code>minZoom</code> Float 1f The minimum zoom scale <code>maxZoom</code> Float 4f The maximum zoom scale <code>doubleTapZoom</code> Float 2f The zoom scale to apply when double-tapping <code>enableDoubleTapZoom</code> Boolean true Whether double-tap to zoom gesture is enabled <code>enableSubSampling</code> Boolean false Whether sub-sampling for large images is enabled <code>subSamplingConfig</code> SubSamplingConfig SubSamplingConfig() Configuration for sub-sampling behavior"},{"location":"zoomable/#gestures","title":"Gestures","text":"<p>The <code>ZoomablePlugin</code> supports the following gestures:</p> <ul> <li>Pinch to zoom: Use two fingers to zoom in/out</li> <li>Double-tap to zoom: Double-tap to toggle between original and zoomed state</li> <li>Pan: Drag to pan around when zoomed in</li> </ul>"},{"location":"zoomable/#sub-sampling","title":"Sub-Sampling","text":"<p>For very large images, Landscapist supports sub-sampling to efficiently display high-resolution images without running out of memory. This feature loads only the visible tiles at the appropriate resolution.</p>"},{"location":"zoomable/#enabling-sub-sampling","title":"Enabling Sub-Sampling","text":"<pre><code>val zoomableState = rememberZoomableState(\n  config = ZoomableConfig(\n    enableSubSampling = true,\n    subSamplingConfig = SubSamplingConfig(\n      tileSize = 512.dp,     // Size of each tile (default: 512.dp)\n      threshold = 2000.dp,   // Minimum image dimension to enable sub-sampling\n    )\n  )\n)\n\nGlideImage(\n  imageModel = { imageUrl },\n  component = rememberImageComponent {\n    +ZoomablePlugin(state = zoomableState)\n  }\n)\n</code></pre>"},{"location":"zoomable/#subsamplingconfig-options","title":"SubSamplingConfig Options","text":"Parameter Type Default Description <code>tileSize</code> Dp 512.dp The size of each tile. Larger tiles mean fewer tiles but more memory per tile <code>threshold</code> Dp 2000.dp The minimum image dimension to enable sub-sampling. Images smaller than this will be rendered normally"},{"location":"zoomable/#sub-sampling-support-by-image-loader","title":"Sub-Sampling Support by Image Loader","text":"Image Loader Android iOS/Desktop Coil3 Supported (network + local) Supported (network + local) Glide Supported (network + local) N/A (Android only) <p>Note</p> <p>Sub-sampling requires the image source to support region decoding. For network images, the image is first cached to disk before sub-sampling can be used.</p>"},{"location":"zoomable/#kotlin-multiplatform-support","title":"Kotlin Multiplatform Support","text":"<p>The <code>ZoomablePlugin</code> supports Kotlin Multiplatform:</p> <ul> <li>Android: Full support with sub-sampling</li> <li>iOS: Full support with sub-sampling (using CGImageSource)</li> <li>Desktop (JVM): Full support with sub-sampling</li> </ul> <p>Add the dependency to your common source set:</p> <pre><code>sourceSets {\n    val commonMain by getting {\n        dependencies {\n            implementation(\"com.github.skydoves:landscapist-zoomable:$version\")\n        }\n    }\n}\n</code></pre>"},{"location":"coil/imageloader/","title":"Custom ImageLoader","text":"<p>Landscapist provides multiple ways to customize the ImageRequest and ImageLoader.</p>"},{"location":"coil/imageloader/#custom-imagerequest-and-imageloader","title":"Custom ImageRequest and ImageLoader","text":"<p>You can load images with your own ImageRequest and ImageLoader, which provides all the necessary information for loading images like caching strategies and transformations.</p> <pre><code>CoilImage(\n  imageRequest = {\n      ImageRequest.Builder(LocalContext.current)\n        .data(poster.poster)\n        .crossfade(true)\n        .build() },\n  imageLoader = {\n      ImageLoader.Builder(LocalContext.current)\n        .availableMemoryPercentage(0.25)\n        .crossfade(true)\n        .build() },\n  modifier = modifier,\n)\n</code></pre>"},{"location":"coil/imageloader/#localcoilimageloader","title":"LocalCoilImageLoader","text":"<p>You can pass the same instance of your <code>ImageLoader</code> down through the Composition in your composable hierarchy as following the example below:</p> <pre><code> val imageLoader = ImageLoader.Builder(context).build()\nCompositionLocalProvider(LocalCoilImageLoader provides imageLoader) {\n\n   // This will automatically use the value of current imageLoader in the hierarchy.\n   CoilImage(\n     imageModel = ...\n   )\n }\n</code></pre>"},{"location":"coil/imageloader/#animated-image-supports-gif-webp","title":"Animated Image Supports (GIF, Webp)","text":"<p>You can load animated GIFs and WebP Images with your <code>ImageLoader</code>.</p> <p></p> <pre><code>val context = LocalContext.current\nval imageLoader = ImageLoader.Builder(context)\n  .components {\n    if (SDK_INT &gt;= 28) {\n      add(ImageDecoderDecoder.Factory())\n    } else {\n      add(GifDecoder.Factory())\n    }\n  }\n  .build()\n\nCoilImage(\n    imageModel = { poster.gif }, // URL of an animated image.\n    imageLoader = { imageLoader },\n    shimmerParams = ShimmerParams(\n      baseColor = background800,\n      highlightColor = shimmerHighLight\n    ),\n    modifier = Modifier\n      .fillMaxWidth()\n      .padding(8.dp)\n      .height(500.dp)\n      .clip(RoundedCornerShape(8.dp))\n  )\n</code></pre>"},{"location":"coil/overview/","title":"Overview","text":"Landscapist Coil <p> Add the dependency below to your module's <code>build.gradle</code> file:</p> GroovyKTS <pre><code>dependencies {\n    implementation \"com.github.skydoves:landscapist-coil:$version\"\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:landscapist-coil:$version\")\n}\n</code></pre> <p>Note</p> <p>Please make sure your project uses the same Jetpack Compose version on the release page.</p>"},{"location":"coil/overview/#coilimage","title":"CoilImage","text":"<p>You can load images by using the <code>CoilImage</code> composable function as the following example below:</p> <pre><code>CoilImage(\n  imageModel = { imageUrl }, // loading a network image or local resource using an URL.\n  imageOptions = ImageOptions(\n    contentScale = ContentScale.Crop,\n    alignment = Alignment.Center\n  )\n)\n</code></pre>"},{"location":"coil/overview/#compose-metrics","title":"Compose Metrics","text":"<p>According to the Compose Compiler Metrics, the <code>CoilImage</code> Composable function is marked as Restartable and Skippable. This means you don't have to worry about performance issues related to re-rendering or re-fetching problems that can occur during recomposition. The Composable function's restartable and skippable nature ensures that the necessary actions are taken to optimize rendering, making it more efficient and seamless.</p> <p></p>"},{"location":"fresco/animated-image/","title":"Fresco Animated Image Support (GIF, Webp)","text":"<p>Add the below dependency to your module's <code>build.gradle</code> file:</p> GroovyKTS <pre><code>dependencies {\n    implementation \"com.github.skydoves:landscapist-fresco-websupport:$version\"\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:landscapist-fresco-websupport:$version\")\n}\n</code></pre> <p></p> <p>You can load animated GIFs and WebP Images with <code>FrescoWebImage</code> composable function. You should pass the <code>AbstractDraweeController</code> like the following example below:</p> <pre><code>FrescoWebImage(\n  controllerBuilder = {\n      Fresco.newDraweeControllerBuilder()\n          .setUri(poster.gif) // GIF or Webp image url.\n          .setAutoPlayAnimations(true)\n  },\n  modifier = Modifier\n    .fillMaxWidth()\n    .height(300.dp)\n)\n</code></pre> <p>For more details, check out DraweeController, and Supported URIs for setting URI addresses. Also, you can load general images (jpeg, png, etc) which can be loaded with <code>FrescoImage</code> by using <code>FrescoWebImage</code> and your custom controller.</p>"},{"location":"fresco/overview/","title":"Overview","text":"Fresco <p>Add the dependency below to your module's <code>build.gradle</code> file:</p> GroovyKTS <pre><code>dependencies {\n    implementation \"com.github.skydoves:landscapist-fresco:$version\"\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:landscapist-fresco:$version\")\n}\n</code></pre> <p>Note</p> <p><code>Landscapist-Fresco</code> includes version <code>2.6.0</code> of Fresco. So please make sure your project is using the same Fresco version or exclude the Fresco dependency to adapt yours. Also, please make sure the Jetpack Compose version on the release page.</p>"},{"location":"fresco/overview/#setup","title":"Setup","text":"<p>To get started, you should set up <code>Fresco</code> with ImagePipelineConfig in your <code>Application</code> class. Generally, it's recommended initializing with <code>OkHttpImagePipelineConfigFactory</code>. Also, you can customize caching, networking, and thread pool strategies with your own <code>ImagePipelineConfig</code>. For more details, you can check out Using Other Network Layers.</p> <pre><code>class App : Application() {\n\n  override fun onCreate() {\n    super.onCreate()\n\n    val pipelineConfig =\n      OkHttpImagePipelineConfigFactory\n        .newBuilder(this, OkHttpClient.Builder().build())\n        .setDiskCacheEnabled(true)\n        .setDownsampleEnabled(true)\n        .setResizeAndRotateEnabledForNetwork(true)\n        .build()\n\n    Fresco.initialize(this, pipelineConfig)\n  }\n}\n</code></pre>"},{"location":"fresco/overview/#frescoimage","title":"FrescoImage","text":"<p>You can load images by using the <code>FrescoImage</code> composable function as the following example below:</p> <pre><code>FrescoImage(\n  imageUrl = stringImageUrl, // loading a network image using an URL.\n  imageOptions = ImageOptions(\n    contentScale = ContentScale.Crop,\n    alignment = Alignment.Center\n  )\n)\n</code></pre>"},{"location":"fresco/overview/#compose-metrics","title":"Compose Metrics","text":"<p>According to the Compose Compiler Metrics, the <code>FrescoImage</code> Composable function is marked as Restartable and Skippable. This means you don't have to worry about performance issues related to re-rendering or re-fetching problems that can occur during recomposition. The Composable function's restartable and skippable nature ensures that the necessary actions are taken to optimize rendering, making it more efficient and seamless.</p> <p></p>"},{"location":"fresco/request/","title":"Custom ImageRequest","text":"<p>Landscapist provides multiple ways to customize the requests.</p>"},{"location":"fresco/request/#custom-imagerequest","title":"Custom ImageRequest","text":"<p>You can load images with your own ImageRequest, which provides some necessary information for loading images like decoding strategies and resizing.</p> <pre><code>val imageRequest = ImageRequestBuilder\n  .newBuilderWithSource(uri)\n  .setImageDecodeOptions(decodeOptions)\n  .setLocalThumbnailPreviewsEnabled(true)\n  .setLowestPermittedRequestLevel(RequestLevel.FULL_FETCH)\n  .setProgressiveRenderingEnabled(false)\n  .setResizeOptions(ResizeOptions(width, height))\n  .build()\n\nFrescoImage(\n  imageUrl = stringImageUrl,\n  imageRequest = { imageRequest }\n)\n</code></pre>"},{"location":"fresco/request/#localfrescoimagerequest","title":"LocalFrescoImageRequest","text":"<p>You can pass the same instance of your <code>imageRequestBuilder</code> down through the Composition in your composable hierarchy as following the example below:</p> <pre><code>// customize the ImageRequest as needed\nval imageRequestBuilder = ImageRequestBuilder\n  .newBuilderWithSource(uri)\n  .setImageDecodeOptions(decodeOptions)\n  .setLocalThumbnailPreviewsEnabled(true)\n  .setLowestPermittedRequestLevel(RequestLevel.FULL_FETCH)\n  .setProgressiveRenderingEnabled(false)\n  .setResizeOptions(ResizeOptions(width, height))\n\nCompositionLocalProvider(LocalFrescoImageRequest provides imageRequestBuilder) {\n  // This will automatically use the value of current ImageRequest in the hierarchy.\n  FrescoImage(\n    imageUrl = ...\n  )\n}\n</code></pre>"},{"location":"glide/options/","title":"Custom Options","text":"<p>Landscapist provides multiple ways to customize the request and transition options.</p>"},{"location":"glide/options/#custom-requestoptions-and-transitionoptions","title":"Custom RequestOptions and TransitionOptions","text":"<p>You can customize your request-options with your own RequestOptions and TransitionOptions for applying caching strategies, loading transformations like below:</p> <pre><code>GlideImage(\n  imageModel = { imageUrl },\n  requestOptions = {\n    RequestOptions()\n        .override(256, 256)\n        .diskCacheStrategy(DiskCacheStrategy.ALL)\n        .centerCrop()\n  }\n)\n</code></pre>"},{"location":"glide/options/#custom-requestbuilder","title":"Custom RequestBuilder","text":"<p>You can request image with your own RequestBuilder, which is the backbone of the request in Glide and is responsible for bringing your options together with your requested url or model to start a new load.</p> <pre><code>GlideImage(\n  imageModel = { imageUrl },\n  requestBuilder = { Glide.with(LocalContext.current.applicationContext).asDrawable() },\n  modifier = Modifier.constrainAs(image) {\n    centerHorizontallyTo(parent)\n    top.linkTo(parent.top)\n  }.aspectRatio(0.8f)\n)\n</code></pre>"},{"location":"glide/options/#custom-requestlistener","title":"Custom RequestListener","text":"<p>You can register your own RequestListener, which allows you to trace the status of a request while images load.</p> <pre><code>GlideImage(\n  imageModel = { imageUrl },\n  requestListener = object: RequestListener&lt;Drawable&gt; {\n    override fun onLoadFailed(\n      e: GlideException?,\n      model: Any?,\n      target: Target&lt;Drawable&gt;?,\n      isFirstResource: Boolean\n    ): Boolean {\n      // do something\n      return false\n    }\n\n    override fun onResourceReady(\n      resource: Drawable?,\n      model: Any?,\n      target: Target&lt;Drawable&gt;?,\n      dataSource: DataSource?,\n      isFirstResource: Boolean\n    ): Boolean {\n      // do something\n      return true\n    }\n  }\n)\n</code></pre>"},{"location":"glide/options/#localgliderequestoptions","title":"LocalGlideRequestOptions","text":"<p>You can pass the same instance of your <code>RequestOptions</code> down through the Composition in your composable hierarchy as following the example below:</p> <pre><code>val requestOptions = RequestOptions()\n    .override(300, 300)\n    .circleCrop()\n\nCompositionLocalProvider(LocalGlideRequestOptions provides requestOptions) {\n  // Loads images with the custom `requestOptions` without explicit defines.\n  GlideImage(\n    imageModel = ...\n  )\n}\n</code></pre>"},{"location":"glide/overview/","title":"Overview","text":"Landscapist Glide"},{"location":"glide/overview/#download","title":"Download","text":"<p>Add the codes below to your root <code>build.gradle</code> file (not your module-level build.gradle file):</p> <pre><code>allprojects {\n    repositories {\n        mavenCentral()\n    }\n}\n</code></pre> <p>Next, add the dependency below to your module's <code>build.gradle</code> file:</p> GroovyKTS <pre><code>dependencies {\n    implementation \"com.github.skydoves:landscapist-glide:2.9.5\"\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:landscapist-glide:2.9.5\")\n}\n</code></pre> <p>Note</p> <p><code>Landscapist-Glide</code> includes version <code>4.15.1</code> of Glide internally. So please make sure your project uses the same Glide version or exclude the Glide dependency to adapt yours. Also, please make sure the Jetpack Compose version on the release page.</p>"},{"location":"glide/overview/#glideimage","title":"GlideImage","text":"<p>You can load images simply by using <code>GlideImage</code> composable function as the following example below:</p> <pre><code>GlideImage(\n  imageModel = { imageUrl }, // loading a network image using an URL.\n  imageOptions = ImageOptions(\n    contentScale = ContentScale.Crop,\n    alignment = Alignment.Center\n  )\n)\n</code></pre>"},{"location":"glide/overview/#compose-metrics","title":"Compose Metrics","text":"<p>According to the Compose Compiler Metrics, the <code>GlideImage</code> Composable function is marked as Restartable and Skippable. This means you don't have to worry about performance issues related to re-rendering or re-fetching problems that can occur during recomposition. The Composable function's restartable and skippable nature ensures that the necessary actions are taken to optimize rendering, making it more efficient and seamless.</p> <p></p>"},{"location":"landscapist/landscapist-core/","title":"Landscapist Core","text":"<p>Kotlin Multiplatform from day one. The <code>landscapist-core</code> module is a complete, standalone image loading engine designed for Kotlin Multiplatform. Unlike the Glide, Coil, or Fresco integrations, this module provides a lightweight, self-contained solution with no external image loading library dependencies, working seamlessly across Android, iOS, Desktop, and Web.</p> <p>See Also: Learn more about Why Choose Landscapist for detailed benefits and comparisons, and Performance Comparison for comprehensive benchmark results.</p>"},{"location":"landscapist/landscapist-core/#key-features","title":"Key Features","text":"<ul> <li>Built on Landscapist Core: Powered by the standalone, platform-agnostic landscapist-core image loading engine with built-in network fetching, memory/disk caching, and image decoding</li> <li>Full Plugin Support: Compatible with all Landscapist plugins (Shimmer, Crossfade, CircularReveal, Blur, Palette, Zoomable, etc.) with support for combining multiple plugins</li> <li>Compose Multiplatform: First-class support for Android, iOS, Desktop, and Web with identical APIs and behavior across all platforms</li> <li>Flexible Sizing: Automatic size calculation from Compose layout constraints with support for explicit dimensions, fill strategies, and aspect ratio preservation</li> <li>Loading States: Built-in composable slots for loading, success, and failure states with full customization support</li> <li>Custom Landscapist Instance: Provide your own configured Landscapist instance via CompositionLocal for fine-grained control over caching, networking, and decoding behavior</li> <li>Image State Callbacks: Monitor and react to loading state changes in real-time with detailed information about data sources, load times, and errors</li> <li>Progressive Loading: Automatic support for progressive JPEG loading that displays low-resolution previews while the full image downloads</li> <li>Multiple Image Sources: Support for network URLs, local files, content URIs, drawable resources, bitmaps, byte arrays, and platform-specific sources</li> <li>Request Customization: Per-request configuration of cache policies, headers, priorities, transformations, and size constraints</li> <li>Memory Efficient: Automatic image downsampling, LRU caching with weak reference pooling, and memory pressure handling</li> </ul>"},{"location":"landscapist/landscapist-core/#installation","title":"Installation","text":""},{"location":"landscapist/landscapist-core/#gradle-android","title":"Gradle (Android)","text":"<p>Add the dependency below to your module's <code>build.gradle</code> file:</p> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:landscapist-core:$version\")\n}\n</code></pre> <p>Note: Ktor client dependencies are included automatically. The module bundles: - <code>ktor-client-core</code> for all platforms - <code>ktor-client-okhttp</code> for Android - <code>ktor-client-darwin</code> for iOS/macOS - <code>ktor-client-cio</code> for Desktop (JVM) - <code>ktor-client-js</code> for Web (Wasm)</p>"},{"location":"landscapist/landscapist-core/#kotlin-multiplatform","title":"Kotlin Multiplatform","text":"<p>Add to your module's <code>build.gradle.kts</code>:</p> <pre><code>kotlin {\n    sourceSets {\n        commonMain.dependencies {\n            implementation(\"com.github.skydoves:landscapist-core:$version\")\n        }\n    }\n}\n</code></pre> <p>All platform-specific Ktor engines are included automatically based on your target platforms.</p>"},{"location":"landscapist/landscapist-core/#basic-usage","title":"Basic Usage","text":""},{"location":"landscapist/landscapist-core/#creating-a-landscapist-instance","title":"Creating a Landscapist Instance","text":""},{"location":"landscapist/landscapist-core/#android","title":"Android","text":"<p>On Android, use the builder with a Context to automatically configure disk caching. You can create an instance with default settings or customize cache sizes and other options to suit your app's needs.</p> <pre><code>import com.skydoves.landscapist.core.Landscapist\nimport com.skydoves.landscapist.core.LandscapistConfig\n\n// Create with default configuration\nval landscapist = Landscapist.builder(context).build()\n\n// Or with custom configuration\nval landscapist = Landscapist.builder(context)\n    .config(\n        LandscapistConfig(\n            memoryCacheSize = 64 * 1024 * 1024L, // 64MB\n            diskCacheSize = 100 * 1024 * 1024L,   // 100MB\n        )\n    )\n    .build()\n</code></pre>"},{"location":"landscapist/landscapist-core/#other-platforms-ios-desktop-web","title":"Other Platforms (iOS, Desktop, Web)","text":"<p>For iOS, Desktop, and Web platforms, use the singleton instance which provides a pre-configured loader. Note that disk caching requires manual directory setup on non-Android platforms.</p> <pre><code>import com.skydoves.landscapist.core.Landscapist\n\n// Get the singleton instance with default configuration\nval landscapist = Landscapist.getInstance()\n\n// Or create a custom instance\nval landscapist = Landscapist.builder()\n    .config(\n        LandscapistConfig(\n            memoryCacheSize = 64 * 1024 * 1024L,\n            // Note: Disk cache requires platform-specific setup\n        )\n    )\n    .build()\n</code></pre>"},{"location":"landscapist/landscapist-core/#loading-images","title":"Loading Images","text":"<p>Load images by creating an ImageRequest and collecting the Flow of results. The loader automatically handles caching, downsampling based on target size, and delivers results through different states (Loading, Success, Failure).</p> <pre><code>import com.skydoves.landscapist.core.ImageRequest\nimport com.skydoves.landscapist.core.model.ImageResult\nimport kotlinx.coroutines.flow.collect\n\nsuspend fun loadImage(url: String) {\n    val request = ImageRequest.builder()\n        .model(url)\n        .size(width = 800, height = 600)\n        .build()\n\n    landscapist.load(request).collect { result -&gt;\n        when (result) {\n            is ImageResult.Loading -&gt; {\n                // Image is loading\n                println(\"Loading...\")\n            }\n            is ImageResult.Success -&gt; {\n                // Image loaded successfully\n                val imageBitmap = result.data\n                val dataSource = result.dataSource // MEMORY, DISK, or NETWORK\n                println(\"Loaded from: $dataSource\")\n            }\n            is ImageResult.Failure -&gt; {\n                // Failed to load image\n                val error = result.reason\n                println(\"Error: ${error.message}\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"landscapist/landscapist-core/#configuration","title":"Configuration","text":""},{"location":"landscapist/landscapist-core/#landscapistconfig","title":"LandscapistConfig","text":"<p>The <code>LandscapistConfig</code> class provides extensive configuration options:</p> <pre><code>val config = LandscapistConfig(\n    // Memory cache configuration\n    memoryCacheSize = 64 * 1024 * 1024L, // 64MB (default)\n    memoryCache = null, // Use custom memory cache implementation\n\n    // Disk cache configuration\n    diskCacheSize = 100 * 1024 * 1024L, // 100MB (default)\n    diskCache = null, // Use custom disk cache implementation\n\n    // Network configuration\n    networkConfig = NetworkConfig(\n        connectTimeout = 10.seconds,\n        readTimeout = 30.seconds,\n        userAgent = \"MyApp/1.0\",\n        defaultHeaders = mapOf(\"Accept\" to \"image/*\"),\n        followRedirects = true,\n        maxRedirects = 5\n    ),\n\n    // Image decoding configuration\n    maxBitmapSize = 4096, // Maximum bitmap dimension\n    allowRgb565 = true, // Use RGB_565 for images without alpha (saves memory)\n\n    // Performance options\n    weakReferencesEnabled = true, // Keep weak references to evicted cache entries\n\n    // Event listener for monitoring\n    eventListenerFactory = EventListener.Factory { request -&gt;\n        object : EventListener {\n            override fun onStart(request: ImageRequest) {\n                println(\"Started: ${request.model}\")\n            }\n\n            override fun onSuccess(request: ImageRequest, result: ImageResult.Success) {\n                println(\"Success: ${result.dataSource}\")\n            }\n\n            override fun onFailure(request: ImageRequest, reason: Throwable) {\n                println(\"Failed: ${reason.message}\")\n            }\n        }\n    },\n\n    // Request/response interceptors\n    interceptors = listOf(\n        // Custom interceptor for modifying requests/responses\n    )\n)\n</code></pre>"},{"location":"landscapist/landscapist-core/#networkconfig","title":"NetworkConfig","text":"<p>Configure HTTP client behavior:</p> <pre><code>val networkConfig = NetworkConfig(\n    connectTimeout = 15.seconds,  // Connection timeout\n    readTimeout = 60.seconds,     // Read timeout\n    userAgent = \"MyApp/2.0\",      // User-Agent header\n    defaultHeaders = mapOf(       // Default headers for all requests\n        \"Accept\" to \"image/*\",\n        \"Accept-Encoding\" to \"gzip\"\n    ),\n    followRedirects = true,       // Follow HTTP redirects\n    maxRedirects = 5              // Maximum redirect hops\n)\n</code></pre>"},{"location":"landscapist/landscapist-core/#image-requests","title":"Image Requests","text":""},{"location":"landscapist/landscapist-core/#imagerequestbuilder","title":"ImageRequest.Builder","text":"<p>Build customized image requests:</p> <pre><code>val request = ImageRequest.builder()\n    // Source model (URL, Uri, File, etc.)\n    .model(\"https://example.com/image.jpg\")\n\n    // Target size for downsampling\n    .size(width = 1024, height = 768)\n\n    // Cache policies\n    .memoryCachePolicy(CachePolicy.ENABLED) // READ_ONLY, WRITE_ONLY, ENABLED, DISABLED\n    .diskCachePolicy(CachePolicy.ENABLED)\n\n    // Request-specific HTTP headers\n    .addHeader(\"Authorization\", \"Bearer token\")\n    .headers(mapOf(\"Custom-Header\" to \"value\"))\n\n    // Image transformations\n    .addTransformation(BlurTransformation(radius = 10))\n    .transformations(listOf(transformation1, transformation2))\n\n    // Priority (HIGH, NORMAL, LOW)\n    .priority(DecodePriority.HIGH)\n\n    // Progressive loading (emit intermediate results)\n    .progressiveEnabled(true)\n\n    // Tag for request management\n    .tag(\"profile-image\")\n\n    .build()\n</code></pre>"},{"location":"landscapist/landscapist-core/#supported-model-types-android","title":"Supported Model Types (Android)","text":"<p>On Android, <code>landscapist-core</code> supports various image source types:</p> <pre><code>// Network URL (String)\nImageRequest.builder().model(\"https://example.com/image.jpg\")\n\n// Content URI\nImageRequest.builder().model(Uri.parse(\"content://media/external/images/1\"))\n\n// File\nImageRequest.builder().model(File(\"/path/to/image.jpg\"))\n\n// Drawable resource\nImageRequest.builder().model(R.drawable.image)\n\n// Bitmap\nImageRequest.builder().model(bitmap)\n\n// ByteArray\nImageRequest.builder().model(byteArray)\n\n// ByteBuffer\nImageRequest.builder().model(byteBuffer)\n\n// Drawable\nImageRequest.builder().model(drawable)\n</code></pre>"},{"location":"landscapist/landscapist-core/#caching","title":"Caching","text":""},{"location":"landscapist/landscapist-core/#memory-cache","title":"Memory Cache","text":"<p>The memory cache uses an LRU (Least Recently Used) eviction policy:</p> <pre><code>// Access the memory cache\nval memoryCache = landscapist.config.memoryCache\n\n// Clear the cache\nmemoryCache?.clear()\n\n// Trim to specific size\nmemoryCache?.trimToSize(32 * 1024 * 1024L) // 32MB\n\n// Get cache stats\nval size = memoryCache?.size\nval maxSize = memoryCache?.maxSize\n</code></pre>"},{"location":"landscapist/landscapist-core/#disk-cache","title":"Disk Cache","text":"<p>Persistent disk cache for offline access:</p> <pre><code>// Disk cache is managed automatically\n// Images are cached to disk on successful network loads\n\n// Clear disk cache\nval diskCache = landscapist.config.diskCache\ndiskCache?.clear()\n</code></pre>"},{"location":"landscapist/landscapist-core/#cache-policies","title":"Cache Policies","text":"<p>Control caching behavior per request:</p> <pre><code>// Read and write to both caches\nCachePolicy.ENABLED\n\n// Only read from cache, never write\nCachePolicy.READ_ONLY\n\n// Only write to cache, never read\nCachePolicy.WRITE_ONLY\n\n// Disable cache completely\nCachePolicy.DISABLED\n\n// Example usage\nval request = ImageRequest.builder()\n    .model(url)\n    .memoryCachePolicy(CachePolicy.ENABLED)\n    .diskCachePolicy(CachePolicy.READ_ONLY)\n    .build()\n</code></pre>"},{"location":"landscapist/landscapist-core/#progressive-loading","title":"Progressive Loading","text":"<p>Progressive loading emits intermediate (blurry) results while decoding large images:</p> <pre><code>val request = ImageRequest.builder()\n    .model(imageUrl)\n    .progressiveEnabled(true) // Enable progressive loading\n    .build()\n\nlandscapist.load(request).collect { result -&gt;\n    when (result) {\n        is ImageResult.Success -&gt; {\n            val bitmap = result.data\n            val isComplete = result.isComplete // false for progressive results\n            // Update UI with intermediate bitmap\n        }\n    }\n}\n</code></pre>"},{"location":"landscapist/landscapist-core/#event-listeners","title":"Event Listeners","text":"<p>Monitor the image loading lifecycle:</p> <pre><code>class LoggingEventListener : EventListener {\n    override fun onStart(request: ImageRequest) {\n        Log.d(\"Image\", \"Loading started: ${request.model}\")\n    }\n\n    override fun onSuccess(request: ImageRequest, result: ImageResult.Success) {\n        Log.d(\"Image\", \"Loaded from ${result.dataSource} in ${result.loadDuration}ms\")\n    }\n\n    override fun onFailure(request: ImageRequest, reason: Throwable) {\n        Log.e(\"Image\", \"Failed to load: ${reason.message}\")\n    }\n\n    override fun onCancel(request: ImageRequest) {\n        Log.d(\"Image\", \"Loading cancelled\")\n    }\n}\n\nval config = LandscapistConfig(\n    eventListenerFactory = EventListener.Factory { request -&gt;\n        LoggingEventListener()\n    }\n)\n</code></pre>"},{"location":"landscapist/landscapist-core/#request-management","title":"Request Management","text":"<p>Cancel and track in-flight requests:</p> <pre><code>// Cancel all requests with a specific tag\nlandscapist.requestManager.cancelRequests(tag = \"profile-images\")\n\n// Cancel all requests\nlandscapist.requestManager.cancelAll()\n\n// Check if requests are in progress\nval hasActiveRequests = landscapist.requestManager.hasActiveRequests()\n</code></pre>"},{"location":"landscapist/landscapist-core/#memory-pressure-handling","title":"Memory Pressure Handling","text":"<p>Landscapist automatically handles memory pressure by trimming caches:</p> <pre><code>// Add custom memory pressure listener\nlandscapist.memoryPressureManager.addListener(object : MemoryPressureListener {\n    override fun onMemoryPressure(level: MemoryPressureLevel) {\n        when (level) {\n            MemoryPressureLevel.LOW -&gt; { /* no action */ }\n            MemoryPressureLevel.MODERATE -&gt; { /* trim some cache */ }\n            MemoryPressureLevel.HIGH -&gt; { /* trim more cache */ }\n            MemoryPressureLevel.CRITICAL -&gt; { /* clear cache */ }\n        }\n    }\n})\n</code></pre>"},{"location":"landscapist/landscapist-core/#custom-decoders","title":"Custom Decoders","text":"<p>Implement custom image decoders for special formats:</p> <pre><code>class WebPDecoder : ImageDecoder {\n    override suspend fun decode(\n        data: ByteArray,\n        targetWidth: Int?,\n        targetHeight: Int?\n    ): DecodeResult {\n        // Custom decoding logic\n        return DecodeResult.Success(imageBitmap)\n    }\n}\n\nval landscapist = Landscapist.builder(context)\n    .decoder(WebPDecoder())\n    .build()\n</code></pre>"},{"location":"landscapist/landscapist-core/#image-transformations","title":"Image Transformations","text":"<p>Apply transformations to loaded images:</p> <pre><code>class CircleCropTransformation : Transformation {\n    override val key: String = \"circle_crop\"\n\n    override suspend fun transform(bitmap: ImageBitmap): ImageBitmap {\n        // Apply circular crop\n        return croppedBitmap\n    }\n}\n\nval request = ImageRequest.builder()\n    .model(imageUrl)\n    .addTransformation(CircleCropTransformation())\n    .build()\n</code></pre>"},{"location":"landscapist/landscapist-core/#data-sources","title":"Data Sources","text":"<p>Track where images are loaded from:</p> <pre><code>landscapist.load(request).collect { result -&gt;\n    if (result is ImageResult.Success) {\n        when (result.dataSource) {\n            DataSource.MEMORY -&gt; println(\"Loaded from memory cache\")\n            DataSource.DISK -&gt; println(\"Loaded from disk cache\")\n            DataSource.NETWORK -&gt; println(\"Downloaded from network\")\n        }\n    }\n}\n</code></pre>"},{"location":"landscapist/landscapist-core/#best-practices","title":"Best Practices","text":"<ol> <li>Reuse Landscapist Instance: Create one instance per app and reuse it</li> <li>Specify Target Size: Always provide target width/height to enable downsampling</li> <li>Use Appropriate Cache Policies: Disable caching for sensitive data</li> <li>Handle Memory Pressure: Monitor memory usage in memory-constrained environments</li> <li>Cancel Requests: Cancel unnecessary requests when navigating away</li> <li>Use Progressive Loading: For large images to improve perceived performance</li> <li>Monitor with Event Listeners: Track performance and errors in production</li> </ol>"},{"location":"landscapist/landscapist-core/#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"landscapist/landscapist-core/#android_1","title":"Android","text":"<ul> <li>Automatically creates disk cache in app's cache directory</li> <li>Supports all Android image sources (URIs, resources, files, etc.)</li> <li>Integrates with Android's memory pressure callbacks</li> </ul>"},{"location":"landscapist/landscapist-core/#ios","title":"iOS","text":"<ul> <li>Uses native image decoders</li> <li>Disk cache requires manual directory setup</li> <li>Memory cache is the primary caching mechanism</li> </ul>"},{"location":"landscapist/landscapist-core/#desktop","title":"Desktop","text":"<ul> <li>Supports file paths and network URLs</li> <li>Configure disk cache path manually</li> <li>Uses Skia for image decoding</li> </ul>"},{"location":"landscapist/landscapist-core/#web-wasm","title":"Web (Wasm)","text":"<ul> <li>Network URLs only</li> <li>In-memory caching only (no persistent disk cache)</li> <li>Limited transformation support</li> </ul>"},{"location":"landscapist/landscapist-core/#see-also","title":"See Also","text":"<ul> <li>Why Choose Landscapist - Key benefits and advantages</li> <li>Performance Comparison - Comprehensive benchmark results</li> <li>Landscapist Image - Compose UI component built on landscapist-core</li> <li>Image Options - Configure image display options</li> <li>Image Component and Plugins - Plugin system for extending functionality</li> </ul>"},{"location":"landscapist/landscapist-image/","title":"Landscapist Image","text":"<p>Compose Multiplatform from day one. The <code>landscapist-image</code> module provides a powerful, production-ready Compose Multiplatform UI component for loading and displaying images using the <code>landscapist-core</code> engine. Unlike platform-specific solutions like GlideImage (Android-only) or FrescoImage (Android-only), LandscapistImage is built from the ground up for Kotlin Multiplatform and Compose Multiplatform, enabling you to write your image loading code once and deploy it across Android, iOS, Desktop, and Web platforms.</p> <p>Built on top of the standalone <code>landscapist-core</code> image loading engine, LandscapistImage gives you complete control over the entire image loading pipeline\u2014from network requests to caching strategies to image transformations\u2014while maintaining seamless compatibility with all Landscapist plugins. This means you get the power and flexibility of a custom image loader combined with the convenience of a high-level Compose API.</p>"},{"location":"landscapist/landscapist-image/#installation","title":"Installation","text":""},{"location":"landscapist/landscapist-image/#gradle-android","title":"Gradle (Android)","text":"<p>Add the dependency below to your module's <code>build.gradle</code> file:</p> <pre><code>dependencies {\n    implementation(\"com.github.skydoves:landscapist-image:$version\")\n\n    // Optional: Add plugins you want to use\n    implementation(\"com.github.skydoves:landscapist-placeholder:$version\")\n    implementation(\"com.github.skydoves:landscapist-animation:$version\")\n}\n</code></pre> <p>Note: This module depends on <code>landscapist-core</code>, which includes Ktor client automatically. No need to add Ktor dependencies separately.</p>"},{"location":"landscapist/landscapist-image/#kotlin-multiplatform","title":"Kotlin Multiplatform","text":"<p>Add to your module's <code>build.gradle.kts</code>:</p> <pre><code>kotlin {\n    sourceSets {\n        commonMain.dependencies {\n            implementation(\"com.github.skydoves:landscapist-image:$version\")\n\n            // Optional plugins\n            implementation(\"com.github.skydoves:landscapist-placeholder:$version\")\n            implementation(\"com.github.skydoves:landscapist-animation:$version\")\n        }\n    }\n}\n</code></pre>"},{"location":"landscapist/landscapist-image/#basic-usage","title":"Basic Usage","text":""},{"location":"landscapist/landscapist-image/#simple-image-loading","title":"Simple Image Loading","text":"<p>The simplest way to load and display an image is to provide an image model (typically a URL) and a modifier specifying the size. LandscapistImage will automatically fetch the image from the network, cache it in memory and on disk, decode it to fit the specified dimensions, and display it in your UI.</p> <pre><code>import com.skydoves.landscapist.image.LandscapistImage\n\nLandscapistImage(\n    imageModel = { \"https://example.com/image.jpg\" },\n    modifier = Modifier.size(200.dp)\n)\n</code></pre> <p>What happens behind the scenes: 1. Size Calculation: The modifier's size constraints are measured during composition 2. Cache Check: Memory cache is checked first for an existing bitmap at the requested size 3. Disk Cache: If not in memory, disk cache is checked for the downloaded image data 4. Network Fetch: If not cached, the image is downloaded via Ktor HTTP client 5. Decoding: The image is decoded and downsampled to match the display size (reducing memory usage) 6. Caching: The decoded bitmap is stored in memory cache, and raw data is stored in disk cache 7. Display: The image is rendered to the screen</p>"},{"location":"landscapist/landscapist-image/#with-imageoptions","title":"With ImageOptions","text":"<p>ImageOptions provides fine-grained control over how the loaded image is displayed. This is separate from the loading pipeline and purely affects the visual presentation once the image is ready.</p> <pre><code>import com.skydoves.landscapist.ImageOptions\nimport androidx.compose.ui.layout.ContentScale\n\nLandscapistImage(\n    imageModel = { imageUrl },\n    modifier = Modifier\n        .fillMaxWidth()\n        .height(250.dp),\n    imageOptions = ImageOptions(\n        contentScale = ContentScale.Crop,        // How to scale the image within bounds\n        alignment = Alignment.Center,             // Where to position the image\n        contentDescription = \"Profile picture\",   // Accessibility description\n        colorFilter = ColorFilter.tint(Color.Red), // Apply color filter\n        alpha = 0.8f                               // Image opacity (0.0 to 1.0)\n    )\n)\n</code></pre> <p>ContentScale options and their use cases: - ContentScale.Crop: Fills the container completely, cropping the image if needed (best for hero images, thumbnails) - ContentScale.Fit: Scales the image to fit within the container without cropping (best for full image viewing) - ContentScale.FillWidth: Fills the width of the container, may crop height (best for banners) - ContentScale.FillHeight: Fills the height of the container, may crop width (best for vertical layouts) - ContentScale.Inside: Scales down only if the image is larger than the container (best for variable-sized images) - ContentScale.None: Displays the image at its original size (best for pixel-perfect graphics)</p>"},{"location":"landscapist/landscapist-image/#using-plugins","title":"Using Plugins","text":"<p>Plugins are modular, composable components that extend LandscapistImage's functionality without modifying its core behavior. They operate on the image loading lifecycle, allowing you to add placeholders, animations, transformations, and other effects. Multiple plugins can be combined and are applied in the order they're added.</p>"},{"location":"landscapist/landscapist-image/#shimmer-placeholder","title":"Shimmer Placeholder","text":"<p>The ShimmerPlugin displays an animated shimmer effect while your image loads, providing visual feedback to users that content is loading. This creates a more polished experience compared to blank spaces or static placeholders. The shimmer animation is highly customizable with control over colors, animation duration, dropoff intensity, and tilt angle.</p> <pre><code>import com.skydoves.landscapist.components.rememberImageComponent\nimport com.skydoves.landscapist.placeholder.shimmer.ShimmerPlugin\n\nLandscapistImage(\n    imageModel = { imageUrl },\n    component = rememberImageComponent {\n        +ShimmerPlugin(\n            baseColor = Color.DarkGray,          // Background color of the shimmer\n            highlightColor = Color.LightGray,    // Color of the shimmer highlight\n            durationMillis = 500,                 // Animation duration (lower = faster)\n            dropOff = 0.65f,                      // How quickly the highlight fades (0.0-1.0)\n            tilt = 20f                            // Angle of the shimmer effect in degrees\n        )\n    }\n)\n</code></pre> <p>Customization tips: - Use brand colors for <code>baseColor</code> and <code>highlightColor</code> to match your app's theme - Reduce <code>durationMillis</code> (e.g., 350-400ms) for a snappier feel on fast networks - Increase <code>dropOff</code> (e.g., 0.8-0.9) for a more subtle, gentle shimmer - Adjust <code>tilt</code> (0\u00b0-45\u00b0) to change the shimmer's direction\u20140\u00b0 is horizontal, 90\u00b0 is vertical</p>"},{"location":"landscapist/landscapist-image/#crossfade-animation","title":"Crossfade Animation","text":"<p>Smoothly crossfade between placeholder and loaded image:</p> <pre><code>import com.skydoves.landscapist.animation.crossfade.CrossfadePlugin\n\nLandscapistImage(\n    imageModel = { imageUrl },\n    component = rememberImageComponent {\n        +CrossfadePlugin(\n            duration = 550 // milliseconds\n        )\n    }\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#circular-reveal-animation","title":"Circular Reveal Animation","text":"<p>Reveal the image with a circular animation:</p> <pre><code>import com.skydoves.landscapist.animation.circular.CircularRevealPlugin\n\nLandscapistImage(\n    imageModel = { imageUrl },\n    component = rememberImageComponent {\n        +CircularRevealPlugin(\n            duration = 800 // milliseconds\n        )\n    }\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#palette-extraction","title":"Palette Extraction","text":"<p>Extract dominant colors from the image:</p> <pre><code>import com.skydoves.landscapist.palette.PalettePlugin\n\nvar palette by remember { mutableStateOf&lt;Palette?&gt;(null) }\n\nLandscapistImage(\n    imageModel = { imageUrl },\n    component = rememberImageComponent {\n        +PalettePlugin { extractedPalette -&gt;\n            palette = extractedPalette\n        }\n    }\n)\n\n// Use extracted colors\npalette?.let {\n    val dominantColor = Color(it.dominantSwatch?.rgb ?: 0)\n    Box(\n        modifier = Modifier\n            .fillMaxWidth()\n            .height(50.dp)\n            .background(dominantColor)\n    )\n}\n</code></pre>"},{"location":"landscapist/landscapist-image/#blur-transformation","title":"Blur Transformation","text":"<p>Apply blur effect to images:</p> <pre><code>import com.skydoves.landscapist.transformation.blur.BlurTransformationPlugin\n\nLandscapistImage(\n    imageModel = { imageUrl },\n    component = rememberImageComponent {\n        +BlurTransformationPlugin(\n            radius = 15 // blur radius\n        )\n    }\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#combining-multiple-plugins","title":"Combining Multiple Plugins","text":"<pre><code>LandscapistImage(\n    imageModel = { imageUrl },\n    component = rememberImageComponent {\n        // Plugins are applied in order\n        +ShimmerPlugin()\n        +CrossfadePlugin(duration = 550)\n        +PalettePlugin { palette -&gt; /* ... */ }\n        +CircularRevealPlugin()\n    }\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#custom-loading-states","title":"Custom Loading States","text":""},{"location":"landscapist/landscapist-image/#loading-composable","title":"Loading Composable","text":"<p>Show a custom composable while the image loads:</p> <pre><code>LandscapistImage(\n    imageModel = { imageUrl },\n    loading = {\n        Box(\n            modifier = Modifier.fillMaxSize(),\n            contentAlignment = Alignment.Center\n        ) {\n            CircularProgressIndicator(\n                modifier = Modifier.size(48.dp),\n                color = MaterialTheme.colors.primary\n            )\n        }\n    }\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#success-composable","title":"Success Composable","text":"<p>Customize how the loaded image is displayed:</p> <pre><code>LandscapistImage(\n    imageModel = { imageUrl },\n    success = { state, painter -&gt;\n        Image(\n            painter = painter,\n            contentDescription = state.imageBitmap?.let { \"Image loaded\" },\n            modifier = Modifier\n                .fillMaxWidth()\n                .clip(RoundedCornerShape(16.dp)),\n            contentScale = ContentScale.Crop\n        )\n    }\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#failure-composable","title":"Failure Composable","text":"<p>Show a custom error state:</p> <pre><code>LandscapistImage(\n    imageModel = { imageUrl },\n    failure = {\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .background(Color.LightGray),\n            contentAlignment = Alignment.Center\n        ) {\n            Column(\n                horizontalAlignment = Alignment.CenterHorizontally,\n                verticalArrangement = Arrangement.Center\n            ) {\n                Icon(\n                    imageVector = Icons.Default.BrokenImage,\n                    contentDescription = \"Failed to load\",\n                    tint = Color.Gray,\n                    modifier = Modifier.size(64.dp)\n                )\n                Text(\n                    text = \"Failed to load image\",\n                    color = Color.Gray,\n                    style = MaterialTheme.typography.body2\n                )\n            }\n        }\n    }\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#all-states-combined","title":"All States Combined","text":"<pre><code>LandscapistImage(\n    imageModel = { imageUrl },\n    modifier = Modifier\n        .fillMaxWidth()\n        .height(200.dp),\n    loading = {\n        Box(Modifier.fillMaxSize()) {\n            CircularProgressIndicator(Modifier.align(Alignment.Center))\n        }\n    },\n    success = { _, painter -&gt;\n        Image(\n            painter = painter,\n            contentDescription = null,\n            contentScale = ContentScale.Crop\n        )\n    },\n    failure = {\n        Box(\n            Modifier\n                .fillMaxSize()\n                .background(Color.LightGray)\n        ) {\n            Text(\n                text = \"Error\",\n                modifier = Modifier.align(Alignment.Center)\n            )\n        }\n    }\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#image-state-changes","title":"Image State Changes","text":"<p>Monitor state changes with a callback:</p> <pre><code>var currentState by remember { mutableStateOf&lt;LandscapistImageState&gt;(LandscapistImageState.None) }\nvar loadTime by remember { mutableStateOf(0L) }\nval startTime = remember { System.currentTimeMillis() }\n\nLandscapistImage(\n    imageModel = { imageUrl },\n    onImageStateChanged = { state -&gt;\n        currentState = state\n        if (state is LandscapistImageState.Success) {\n            loadTime = System.currentTimeMillis() - startTime\n        }\n    }\n)\n\n// Display state information\nwhen (currentState) {\n    is LandscapistImageState.None -&gt; Text(\"Ready to load\")\n    is LandscapistImageState.Loading -&gt; Text(\"Loading...\")\n    is LandscapistImageState.Success -&gt; {\n        val success = currentState as LandscapistImageState.Success\n        Text(\"Loaded in ${loadTime}ms from ${success.dataSource}\")\n    }\n    is LandscapistImageState.Failure -&gt; {\n        val failure = currentState as LandscapistImageState.Failure\n        Text(\"Failed: ${failure.reason.message}\")\n    }\n}\n</code></pre>"},{"location":"landscapist/landscapist-image/#custom-landscapist-instance","title":"Custom Landscapist Instance","text":""},{"location":"landscapist/landscapist-image/#providing-a-custom-instance","title":"Providing a Custom Instance","text":"<p>Use <code>LocalLandscapist</code> to provide a custom Landscapist instance to your composition tree:</p> <pre><code>import com.skydoves.landscapist.core.Landscapist\nimport com.skydoves.landscapist.core.LandscapistConfig\nimport com.skydoves.landscapist.image.LocalLandscapist\nimport androidx.compose.runtime.CompositionLocalProvider\n\n// Create custom Landscapist instance\nval customLandscapist = Landscapist.builder(context)\n    .config(\n        LandscapistConfig(\n            memoryCacheSize = 128 * 1024 * 1024L, // 128MB\n            diskCacheSize = 200 * 1024 * 1024L,    // 200MB\n            networkConfig = NetworkConfig(\n                connectTimeout = 15.seconds,\n                userAgent = \"MyApp/1.0\"\n            )\n        )\n    )\n    .build()\n\n// Provide to composition tree\nCompositionLocalProvider(LocalLandscapist provides customLandscapist) {\n    // All LandscapistImage composables in this tree will use customLandscapist\n    LandscapistImage(\n        imageModel = { imageUrl }\n    )\n}\n</code></pre>"},{"location":"landscapist/landscapist-image/#per-request-configuration","title":"Per-Request Configuration","text":"<p>Customize individual requests:</p> <pre><code>import com.skydoves.landscapist.core.ImageRequest\nimport com.skydoves.landscapist.core.model.CachePolicy\n\nLandscapistImage(\n    imageModel = { imageUrl },\n    requestBuilder = {\n        // Customize this specific request\n        size(width = 1024, height = 768)\n        memoryCachePolicy(CachePolicy.DISABLED)\n        addHeader(\"Authorization\", \"Bearer token\")\n        priority(DecodePriority.HIGH)\n    }\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#supported-image-sources","title":"Supported Image Sources","text":""},{"location":"landscapist/landscapist-image/#android","title":"Android","text":"<p><code>LandscapistImage</code> on Android supports a wide variety of image sources:</p> <pre><code>// Network URLs\nLandscapistImage(imageModel = { \"https://example.com/image.jpg\" })\n\n// Content URIs\nval contentUri = Uri.parse(\"content://media/external/images/1\")\nLandscapistImage(imageModel = { contentUri })\n\n// File paths\nval file = File(\"/storage/emulated/0/image.jpg\")\nLandscapistImage(imageModel = { file })\n\n// Drawable resources\nLandscapistImage(imageModel = { R.drawable.profile_placeholder })\n\n// Asset files\nLandscapistImage(imageModel = { \"file:///android_asset/image.png\" })\n\n// Bitmap instances\nval bitmap: Bitmap = ...\nLandscapistImage(imageModel = { bitmap })\n\n// Byte arrays\nval bytes: ByteArray = ...\nLandscapistImage(imageModel = { bytes })\n\n// Drawable instances\nval drawable: Drawable = ...\nLandscapistImage(imageModel = { drawable })\n</code></pre>"},{"location":"landscapist/landscapist-image/#ios-desktop-web","title":"iOS, Desktop, Web","text":"<p>On other platforms, supported sources depend on the platform:</p> <pre><code>// Network URLs (all platforms)\nLandscapistImage(imageModel = { \"https://example.com/image.jpg\" })\n\n// File paths (Desktop, iOS)\nLandscapistImage(imageModel = { \"/path/to/image.jpg\" })\n\n// Platform-specific models\n// Check landscapist-core documentation for details\n</code></pre>"},{"location":"landscapist/landscapist-image/#sizing-behavior","title":"Sizing Behavior","text":""},{"location":"landscapist/landscapist-image/#explicit-size","title":"Explicit Size","text":"<p>Provide explicit dimensions:</p> <pre><code>LandscapistImage(\n    imageModel = { imageUrl },\n    modifier = Modifier.size(300.dp)\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#fill-available-space","title":"Fill Available Space","text":"<p>Fill the parent container:</p> <pre><code>LandscapistImage(\n    imageModel = { imageUrl },\n    modifier = Modifier\n        .fillMaxWidth()\n        .height(200.dp)\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#aspect-ratio","title":"Aspect Ratio","text":"<p>Maintain aspect ratio:</p> <pre><code>LandscapistImage(\n    imageModel = { imageUrl },\n    modifier = Modifier\n        .fillMaxWidth()\n        .aspectRatio(16f / 9f)\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#placeholder-aspect-ratio","title":"Placeholder Aspect Ratio","text":"<p>Reserve space before the image loads:</p> <pre><code>LandscapistImage(\n    imageModel = { imageUrl },\n    imageOptions = ImageOptions(\n        placeholderAspectRatio = 16f / 9f\n    ),\n    modifier = Modifier.fillMaxWidth()\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#advanced-usage","title":"Advanced Usage","text":""},{"location":"landscapist/landscapist-image/#lazy-column-with-images","title":"Lazy Column with Images","text":"<p>Efficiently load images in a scrolling list:</p> <pre><code>LazyColumn {\n    items(imageUrls) { url -&gt;\n        LandscapistImage(\n            imageModel = { url },\n            modifier = Modifier\n                .fillMaxWidth()\n                .height(200.dp)\n                .padding(8.dp),\n            component = rememberImageComponent {\n                +ShimmerPlugin()\n                +CrossfadePlugin()\n            }\n        )\n    }\n}\n</code></pre>"},{"location":"landscapist/landscapist-image/#hero-image-with-fade-in","title":"Hero Image with Fade-in","text":"<pre><code>var isImageLoaded by remember { mutableStateOf(false) }\n\nBox(modifier = Modifier.fillMaxSize()) {\n    LandscapistImage(\n        imageModel = { heroImageUrl },\n        modifier = Modifier\n            .fillMaxSize()\n            .alpha(if (isImageLoaded) 1f else 0f),\n        onImageStateChanged = { state -&gt;\n            isImageLoaded = state is LandscapistImageState.Success\n        }\n    )\n\n    if (!isImageLoaded) {\n        CircularProgressIndicator(\n            modifier = Modifier.align(Alignment.Center)\n        )\n    }\n}\n</code></pre>"},{"location":"landscapist/landscapist-image/#profile-picture-with-placeholder","title":"Profile Picture with Placeholder","text":"<pre><code>LandscapistImage(\n    imageModel = { profileImageUrl },\n    modifier = Modifier\n        .size(80.dp)\n        .clip(CircleShape)\n        .border(2.dp, MaterialTheme.colors.primary, CircleShape),\n    imageOptions = ImageOptions(\n        contentScale = ContentScale.Crop\n    ),\n    component = rememberImageComponent {\n        +ShimmerPlugin()\n    },\n    failure = {\n        // Show default avatar on failure\n        Icon(\n            imageVector = Icons.Default.Person,\n            contentDescription = \"Default avatar\",\n            modifier = Modifier\n                .fillMaxSize()\n                .background(Color.LightGray)\n                .padding(16.dp),\n            tint = Color.Gray\n        )\n    }\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#zoomable-image","title":"Zoomable Image","text":"<p>Combine with ZoomablePlugin for pinch-to-zoom:</p> <pre><code>import com.skydoves.landscapist.zoomable.ZoomablePlugin\nimport com.skydoves.landscapist.zoomable.rememberZoomableState\n\nval zoomableState = rememberZoomableState()\n\nLandscapistImage(\n    imageModel = { largeImageUrl },\n    modifier = Modifier.fillMaxSize(),\n    component = rememberImageComponent {\n        +ZoomablePlugin(state = zoomableState)\n    }\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#migration-guide","title":"Migration Guide","text":""},{"location":"landscapist/landscapist-image/#from-glideimagecoilimagefrescoimage","title":"From GlideImage/CoilImage/FrescoImage","text":"<p>Migrating from other image loaders is straightforward:</p> <pre><code>// Before (GlideImage)\nGlideImage(\n    imageModel = { imageUrl },\n    modifier = Modifier.size(200.dp)\n)\n\n// After (LandscapistImage)\nLandscapistImage(\n    imageModel = { imageUrl },\n    modifier = Modifier.size(200.dp)\n)\n</code></pre> <p>The API is intentionally similar for easy migration. Most parameters work identically.</p>"},{"location":"landscapist/landscapist-image/#plugin-migration","title":"Plugin Migration","text":"<p>All plugins work the same way:</p> <pre><code>// Before (with GlideImage)\nGlideImage(\n    imageModel = { imageUrl },\n    component = rememberImageComponent {\n        +ShimmerPlugin()\n        +CrossfadePlugin()\n    }\n)\n\n// After (with LandscapistImage)\nLandscapistImage(\n    imageModel = { imageUrl },\n    component = rememberImageComponent {\n        +ShimmerPlugin()\n        +CrossfadePlugin()\n    }\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#common-patterns-and-recipes","title":"Common Patterns and Recipes","text":""},{"location":"landscapist/landscapist-image/#image-grid-with-different-sizes","title":"Image Grid with Different Sizes","text":"<p>Load images efficiently in a grid where different items have different dimensions:</p> <pre><code>LazyVerticalGrid(\n    columns = GridCells.Fixed(2),\n    contentPadding = PaddingValues(8.dp)\n) {\n    items(imageList) { item -&gt;\n        LandscapistImage(\n            imageModel = { item.url },\n            modifier = Modifier\n                .fillMaxWidth()\n                .aspectRatio(item.aspectRatio)\n                .padding(4.dp)\n                .clip(RoundedCornerShape(8.dp)),\n            imageOptions = ImageOptions(\n                contentScale = ContentScale.Crop\n            ),\n            component = rememberImageComponent {\n                +ShimmerPlugin()\n                +CrossfadePlugin()\n            }\n        )\n    }\n}\n</code></pre>"},{"location":"landscapist/landscapist-image/#avatar-with-loading-indicator-and-fallback","title":"Avatar with Loading Indicator and Fallback","text":"<p>Implement a complete avatar component with loading state, error fallback, and circular clipping:</p> <pre><code>@Composable\nfun Avatar(\n    imageUrl: String?,\n    name: String,\n    modifier: Modifier = Modifier,\n    size: Dp = 48.dp\n) {\n    Box(modifier = modifier.size(size)) {\n        LandscapistImage(\n            imageModel = { imageUrl },\n            modifier = Modifier\n                .fillMaxSize()\n                .clip(CircleShape),\n            imageOptions = ImageOptions(\n                contentScale = ContentScale.Crop,\n                contentDescription = \"Avatar for $name\"\n            ),\n            loading = {\n                CircularProgressIndicator(\n                    modifier = Modifier\n                        .size(size / 2)\n                        .align(Alignment.Center),\n                    strokeWidth = 2.dp\n                )\n            },\n            failure = {\n                // Show first letter of name as fallback\n                Box(\n                    modifier = Modifier\n                        .fillMaxSize()\n                        .background(\n                            color = MaterialTheme.colors.primary,\n                            shape = CircleShape\n                        ),\n                    contentAlignment = Alignment.Center\n                ) {\n                    Text(\n                        text = name.firstOrNull()?.uppercase() ?: \"?\",\n                        color = Color.White,\n                        style = MaterialTheme.typography.h6\n                    )\n                }\n            }\n        )\n    }\n}\n</code></pre>"},{"location":"landscapist/landscapist-image/#full-screen-image-viewer-with-pinch-to-zoom","title":"Full-Screen Image Viewer with Pinch-to-Zoom","text":"<p>Create a full-screen image viewer with zoom and pan capabilities:</p> <pre><code>@Composable\nfun FullScreenImageViewer(\n    imageUrl: String,\n    onDismiss: () -&gt; Unit\n) {\n    val zoomableState = rememberZoomableState(\n        minScale = 1f,\n        maxScale = 5f\n    )\n\n    Box(\n        modifier = Modifier\n            .fillMaxSize()\n            .background(Color.Black)\n            .clickable { onDismiss() }\n    ) {\n        LandscapistImage(\n            imageModel = { imageUrl },\n            modifier = Modifier.fillMaxSize(),\n            imageOptions = ImageOptions(\n                contentScale = ContentScale.Fit,\n                alignment = Alignment.Center\n            ),\n            component = rememberImageComponent {\n                +ZoomablePlugin(\n                    state = zoomableState,\n                    enableSubSampling = true  // For very large images\n                )\n            },\n            loading = {\n                Box(\n                    modifier = Modifier.fillMaxSize(),\n                    contentAlignment = Alignment.Center\n                ) {\n                    Column(horizontalAlignment = Alignment.CenterHorizontally) {\n                        CircularProgressIndicator(color = Color.White)\n                        Spacer(Modifier.height(16.dp))\n                        Text(\"Loading high resolution image...\", color = Color.White)\n                    }\n                }\n            }\n        )\n\n        // Close button\n        IconButton(\n            onClick = onDismiss,\n            modifier = Modifier\n                .align(Alignment.TopEnd)\n                .padding(16.dp)\n        ) {\n            Icon(\n                imageVector = Icons.Default.Close,\n                contentDescription = \"Close\",\n                tint = Color.White\n            )\n        }\n\n        // Zoom indicator\n        Text(\n            text = \"Zoom: ${(zoomableState.scale * 100).toInt()}%\",\n            color = Color.White,\n            modifier = Modifier\n                .align(Alignment.BottomCenter)\n                .padding(16.dp)\n                .background(Color.Black.copy(alpha = 0.5f), RoundedCornerShape(8.dp))\n                .padding(horizontal = 16.dp, vertical = 8.dp)\n        )\n    }\n}\n</code></pre>"},{"location":"landscapist/landscapist-image/#product-image-with-palette-based-ui","title":"Product Image with Palette-Based UI","text":"<p>Extract colors from product images to create dynamic, branded UI:</p> <pre><code>@Composable\nfun ProductCard(product: Product) {\n    var palette by remember { mutableStateOf&lt;Palette?&gt;(null) }\n    val backgroundColor = remember(palette) {\n        palette?.vibrantSwatch?.rgb?.let { Color(it) } ?: Color.LightGray\n    }\n    val textColor = remember(palette) {\n        palette?.vibrantSwatch?.titleTextColor?.let { Color(it) } ?: Color.Black\n    }\n\n    Card(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(16.dp),\n        backgroundColor = backgroundColor.copy(alpha = 0.1f)\n    ) {\n        Column {\n            LandscapistImage(\n                imageModel = { product.imageUrl },\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(200.dp),\n                imageOptions = ImageOptions(\n                    contentScale = ContentScale.Crop\n                ),\n                component = rememberImageComponent {\n                    +PalettePlugin { extractedPalette -&gt;\n                        palette = extractedPalette\n                    }\n                    +CrossfadePlugin()\n                }\n            )\n\n            Column(\n                modifier = Modifier.padding(16.dp)\n            ) {\n                Text(\n                    text = product.name,\n                    style = MaterialTheme.typography.h6,\n                    color = textColor\n                )\n                Text(\n                    text = product.price,\n                    style = MaterialTheme.typography.body1,\n                    color = textColor.copy(alpha = 0.7f)\n                )\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"landscapist/landscapist-image/#infinite-scrolling-feed-with-prefetching","title":"Infinite Scrolling Feed with Prefetching","text":"<p>Implement an efficient infinite scroll feed that prefetches images:</p> <pre><code>@Composable\nfun ImageFeed(\n    items: List&lt;FeedItem&gt;,\n    onLoadMore: () -&gt; Unit\n) {\n    val listState = rememberLazyListState()\n    val landscapist = LocalLandscapist.current\n\n    // Prefetch next images when user is near the end\n    LaunchedEffect(listState) {\n        snapshotFlow { listState.layoutInfo.visibleItemsInfo.lastOrNull()?.index }\n            .collect { lastVisibleIndex -&gt;\n                if (lastVisibleIndex != null &amp;&amp; lastVisibleIndex &gt;= items.size - 3) {\n                    onLoadMore()\n                    // Prefetch next images\n                    items.drop(lastVisibleIndex + 1).take(5).forEach { item -&gt;\n                        landscapist.load(\n                            ImageRequest.builder()\n                                .model(item.imageUrl)\n                                .size(width = 1080, height = 1080)\n                                .build()\n                        ).collect { /* Prefetch only */ }\n                    }\n                }\n            }\n    }\n\n    LazyColumn(state = listState) {\n        items(items) { item -&gt;\n            LandscapistImage(\n                imageModel = { item.imageUrl },\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .aspectRatio(1f),\n                component = rememberImageComponent {\n                    +ShimmerPlugin()\n                }\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"landscapist/landscapist-image/#performance-optimization","title":"Performance Optimization","text":""},{"location":"landscapist/landscapist-image/#sizing-best-practices","title":"Sizing Best Practices","text":"<p>Always provide explicit size constraints to enable proper image downsampling and prevent memory waste:</p> <pre><code>// \u2705 GOOD: Explicit size allows downsampling\nLandscapistImage(\n    imageModel = { hugeImageUrl },\n    modifier = Modifier.size(200.dp)  // Image downsampled to ~200x200 pixels\n)\n\n// \u274c BAD: No size constraints, loads full resolution\nLandscapistImage(\n    imageModel = { hugeImageUrl }\n    // May load 4000x4000 image into memory!\n)\n\n// \u2705 GOOD: fillMaxWidth with aspectRatio\nLandscapistImage(\n    imageModel = { imageUrl },\n    modifier = Modifier\n        .fillMaxWidth()\n        .aspectRatio(16f / 9f)  // Size can be calculated\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#memory-optimization-for-large-lists","title":"Memory Optimization for Large Lists","text":"<p>Configure aggressive caching policies for scrolling lists to prevent memory issues:</p> <pre><code>val customLandscapist = remember {\n    Landscapist.builder(context)\n        .config(\n            LandscapistConfig(\n                memoryCacheSize = 50 * 1024 * 1024L,  // 50MB - smaller for lists\n                weakReferencesEnabled = true,          // Enable weak reference pool\n                allowRgb565 = true                     // Use 16-bit color (saves 50% memory)\n            )\n        )\n        .build()\n}\n\nCompositionLocalProvider(LocalLandscapist provides customLandscapist) {\n    LazyColumn {\n        items(1000) { index -&gt;\n            LandscapistImage(\n                imageModel = { items[index].url },\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(150.dp),\n                requestBuilder = {\n                    // Disable memory cache for list items that scroll off screen\n                    memoryCachePolicy(CachePolicy.READ_ONLY)\n                }\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"landscapist/landscapist-image/#network-performance","title":"Network Performance","text":"<p>Optimize network loading with custom Ktor configuration:</p> <pre><code>val landscapist = Landscapist.builder(context)\n    .config(\n        LandscapistConfig(\n            networkConfig = NetworkConfig(\n                connectTimeout = 5.seconds,       // Fast fail for poor connections\n                readTimeout = 30.seconds,         // Reasonable timeout for large images\n                followRedirects = true,\n                maxRedirects = 3,                 // Prevent redirect loops\n                defaultHeaders = mapOf(\n                    \"Accept\" to \"image/webp,image/jpeg,image/png,image/*\",\n                    \"Accept-Encoding\" to \"gzip, deflate\"\n                )\n            )\n        )\n    )\n    .build()\n</code></pre>"},{"location":"landscapist/landscapist-image/#progressive-loading-for-better-ux","title":"Progressive Loading for Better UX","text":"<p>Enable progressive loading for large JPEG images to show previews while downloading:</p> <pre><code>LandscapistImage(\n    imageModel = { largeImageUrl },\n    modifier = Modifier.fillMaxSize(),\n    requestBuilder = {\n        progressiveEnabled(true)  // Show progressive previews\n        priority(DecodePriority.HIGH)  // Prioritize this image\n    },\n    onImageStateChanged = { state -&gt;\n        if (state is LandscapistImageState.Success &amp;&amp; !state.isComplete) {\n            // Showing progressive preview\n            Log.d(\"Image\", \"Progressive preview loaded\")\n        }\n    }\n)\n</code></pre>"},{"location":"landscapist/landscapist-image/#troubleshooting","title":"Troubleshooting","text":""},{"location":"landscapist/landscapist-image/#images-not-loading","title":"Images Not Loading","text":"<p>Problem: Images don't appear, no error shown Solutions: 1. Check internet permission in AndroidManifest.xml:    <pre><code>&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n</code></pre> 2. Verify the URL is accessible (check CORS for web) 3. Add an <code>onImageStateChanged</code> callback to see exact errors:    <pre><code>LandscapistImage(\n    imageModel = { url },\n    onImageStateChanged = { state -&gt;\n        when (state) {\n            is LandscapistImageState.Failure -&gt; {\n                Log.e(\"Image\", \"Failed to load: ${state.reason}\")\n            }\n            else -&gt; {}\n        }\n    }\n)\n</code></pre></p>"},{"location":"landscapist/landscapist-image/#out-of-memory-errors","title":"Out of Memory Errors","text":"<p>Problem: App crashes with OutOfMemoryError when loading large images Solutions: 1. Always specify size constraints:    <pre><code>modifier = Modifier.size(300.dp)  // Not Modifier.fillMaxSize()!\n</code></pre> 2. Reduce memory cache size:    <pre><code>LandscapistConfig(memoryCacheSize = 32 * 1024 * 1024L)\n</code></pre> 3. Enable RGB_565 for images without transparency:    <pre><code>LandscapistConfig(allowRgb565 = true)\n</code></pre></p>"},{"location":"landscapist/landscapist-image/#slow-loading-in-lists","title":"Slow Loading in Lists","text":"<p>Problem: Images load slowly when scrolling through a list Solutions: 1. Use appropriate cache policies:    <pre><code>requestBuilder = {\n    memoryCachePolicy(CachePolicy.ENABLED)\n    diskCachePolicy(CachePolicy.ENABLED)\n}\n</code></pre> 2. Prefetch images before they're visible (see \"Infinite Scrolling Feed\" example above) 3. Use smaller thumbnail URLs when available:    <pre><code>imageModel = { item.thumbnailUrl ?: item.fullUrl }\n</code></pre></p>"},{"location":"landscapist/landscapist-image/#images-pixelated-or-blurry","title":"Images Pixelated or Blurry","text":"<p>Problem: Images appear low quality despite being high resolution Solutions: 1. Check that size constraints match the display size:    <pre><code>// If displaying at 500x500dp, request that size\nmodifier = Modifier.size(500.dp)\n</code></pre> 2. Disable downsampling for specific images:    <pre><code>requestBuilder = {\n    size(width = Int.MAX_VALUE, height = Int.MAX_VALUE)\n}\n</code></pre> 3. Use appropriate ContentScale:    <pre><code>imageOptions = ImageOptions(contentScale = ContentScale.Fit)\n</code></pre></p>"},{"location":"landscapist/landscapist-image/#crossfade-animation-not-working","title":"Crossfade Animation Not Working","text":"<p>Problem: CrossfadePlugin doesn't animate Solutions: 1. Ensure the image isn't already in cache (cache hits skip the animation) 2. Clear cache for testing:    <pre><code>landscapist.config.memoryCache?.clear()\n</code></pre> 3. Increase duration to make it visible:    <pre><code>+CrossfadePlugin(duration = 1000)  // 1 second\n</code></pre></p>"},{"location":"landscapist/landscapist-image/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always Provide Image Size: Specify size constraints using modifiers to enable automatic downsampling and prevent excessive memory usage. This is the single most important optimization.</p> </li> <li> <p>Use Plugins Wisely: While plugins are powerful, each adds processing overhead. Only use plugins that provide value to your specific use case. Avoid combining more than 3-4 plugins on a single image.</p> </li> <li> <p>Handle All States: Always provide loading and failure composables for better UX. Users should never see blank spaces or wonder if something is wrong.</p> </li> <li> <p>Reuse Components: Use <code>rememberImageComponent</code> outside of loops when the same plugin configuration is used for multiple images. This prevents unnecessary recomposition.</p> </li> <li> <p>Configure Caching Appropriately: Customize memory and disk cache sizes based on your app's needs. A typical app might use 64MB memory + 150MB disk, but adjust based on your image sizes and quantities.</p> </li> <li> <p>Monitor Performance: Use <code>onImageStateChanged</code> to track loading times, cache hit rates, and failures. Log this data in development to identify optimization opportunities.</p> </li> <li> <p>Optimize for Lists: When displaying images in scrolling lists, use smaller cache sizes, enable weak references, and consider READ_ONLY cache policy to prevent cache thrashing.</p> </li> <li> <p>Test on Low-End Devices: Always test image loading on devices with limited memory and slow networks to ensure a good experience for all users.</p> </li> <li> <p>Use ContentDescription: Always provide accessibility descriptions via <code>ImageOptions.contentDescription</code> for screen reader support.</p> </li> <li> <p>Consider Progressive Loading: For large images (&gt;1MB), enable progressive loading to improve perceived performance by showing low-resolution previews quickly.</p> </li> </ol>"},{"location":"landscapist/landscapist-image/#limitations","title":"Limitations","text":"<ul> <li>Progressive loading: Only works with progressive JPEG images from network sources. PNG, WebP, and local images don't support progressive loading.</li> <li>Animated images: GIF animation support is platform-dependent. Android uses native decoders, while other platforms may only show the first frame. WebP animation support varies by platform and OS version.</li> <li>Platform differences: Some features are platform-specific:</li> <li>Content URIs: Android only</li> <li>Drawable resources: Android only</li> <li>Asset files: Platform-specific paths</li> <li>SubSampling (for very large images): Best support on Android</li> <li>Memory constraints: Very large images (&gt;4096x4096) may fail to load on some devices due to GPU texture size limits or memory constraints</li> </ul>"},{"location":"landscapist/landscapist-image/#see-also","title":"See Also","text":"<ul> <li>Why Choose Landscapist - Key benefits and advantages</li> <li>Performance Comparison - Comprehensive benchmark results</li> <li>Landscapist Core - The underlying image loading engine</li> <li>Image Options - Configure image display options</li> <li>Image Component and Plugins - Plugin system details</li> <li>Placeholder - Placeholder options</li> <li>Animation - Animation plugins</li> <li>Zoomable - Zoomable image support</li> <li>Palette - Color extraction</li> </ul>"},{"location":"landscapist/performance-comparison/","title":"Performance Comparison","text":"<p>Comprehensive performance benchmarks comparing LandscapistImage against industry-standard image loading libraries (Glide, Coil, Fresco).</p>"},{"location":"landscapist/performance-comparison/#standard-image-performance-300dp","title":"Standard Image Performance (300.dp)","text":"<p>The table below shows performance metrics for loading a 200KB network image (cold cache, initial load, 300dp size) on Android. Tests run 5 rounds per library with comprehensive cache clearing (Glide, Landscapist, Coil) and report averaged results from network request to decoded bitmap ready for display.</p> Library Avg Load Time Min/Max Range Avg Memory Min/Max Range Supports KMP LandscapistImage 1,194ms 1,136-1,276ms &lt; 1 MB (est.)* 0 KB retained \u2713 GlideImage 3,053ms (+156%) 3,047-3,058ms 7,810 KB 7,649-7,883 KB \u2717 FrescoImage 3,058ms (+156%) 3,052-3,071ms 1,166 KB 1,110-1,226 KB \u2717 CoilImage (Coil3) 3,114ms (+161%) 3,107-3,125ms 12,659 KB 12,481-12,844 KB \u2713 <p>*Memory Estimation: LandscapistImage's streaming decoder processes images in tiles and releases memory immediately after compositing. Peak memory during decode is estimated &lt; 1 MB (tile buffers + decompression), followed by immediate cleanup (0 KB retained, measured). Competitors retain full decoded bitmaps (1.2-12.7 MB) after load completion.</p>"},{"location":"landscapist/performance-comparison/#performance-highlights-300dp","title":"Performance Highlights (300.dp)","text":"<ul> <li>Significantly Faster: LandscapistImage is 2.6x faster than all competitors (156-161% faster)</li> <li>Memory Efficiency: Immediate memory release after compositing - no retained bitmaps in memory</li> <li>Consistent Performance: Tight variance (140ms range: 1,136-1,276ms)</li> <li>Multiplatform Ready: Only LandscapistImage and Coil support Kotlin Multiplatform</li> <li>Platform Limitation: Glide and Fresco are Android-only</li> </ul>"},{"location":"landscapist/performance-comparison/#why-landscapistimage-is-faster","title":"Why LandscapistImage is Faster","text":"<ol> <li>Optimized Decoding Pipeline: Direct integration between network fetching (Ktor) and image decoding eliminates intermediate buffering.</li> <li>Efficient Downsampling: Progressive decoding at target size during download, not after.</li> <li>Smart Memory Management: Weak reference pooling and LRU caching reduce GC pressure.</li> <li>Minimal Abstraction: Built-in loader with no wrapper overhead.</li> </ol> <p>Test Methodology: Performance numbers averaged across 5 rounds of instrumented tests on Android 16 emulator. Each test loads a fresh 200KB JPEG from network (GitHub CDN, no cache) at 300dp size. All caches cleared between runs. Measurements from <code>setContent</code> to fully decoded bitmap. See ComprehensivePerformanceTest.kt for full implementation.</p>"},{"location":"landscapist/performance-comparison/#large-image-performance-1200dp","title":"Large Image Performance (1200.dp)","text":"<p>For larger images (1200.dp), the performance advantage of LandscapistImage becomes even more pronounced. The table below shows the same test methodology with 1200.dp image size:</p> Library Avg Load Time Min/Max Range Avg Memory Min/Max Range Supports KMP LandscapistImage 1,447ms 1,266-1,669ms &lt; 2 MB (est.)* 0 KB retained \u2713 GlideImage 3,052ms (+111%) 3,044-3,061ms 19,348 KB 19,307-19,425 KB \u2717 FrescoImage 3,054ms (+111%) 3,046-3,064ms 1,318 KB 1,196-1,548 KB \u2717 CoilImage (Coil3) 3,114ms (+115%) 3,109-3,117ms 12,504 KB 12,464-12,519 KB \u2713 <p>*Memory Estimation (1200.dp): Peak memory during streaming decode estimated &lt; 2 MB (larger tile buffers for 16x pixel area), followed by immediate cleanup (0 KB retained). Memory scaling with image size: GlideImage retains 2.5x more memory for larger images (7.8 MB \u2192 19.3 MB), while LandscapistImage's streaming approach maintains minimal peak memory regardless of display size.</p>"},{"location":"landscapist/performance-comparison/#large-image-performance-highlights-1200dp","title":"Large Image Performance Highlights (1200.dp)","text":"<ul> <li>Dramatically Faster: LandscapistImage is 2.1x faster than all competitors (111-115% faster)</li> <li>Memory Efficiency: Immediate memory release after compositing (0 KB retained vs 1.3-19 MB for competitors)</li> <li>Scalability: Minimal performance degradation with size increase (1,194ms \u2192 1,447ms for 16x pixel area)</li> <li>Consistent Speed: Variance of 403ms (1,266-1,669ms) with worst-case still 1.8x faster than competitors' average</li> <li>Memory Scaling: Glide memory increases 2.5x (7.8 MB \u2192 19.3 MB) for larger images</li> </ul>"},{"location":"landscapist/performance-comparison/#why-the-performance-gap-widens","title":"Why the Performance Gap Widens","text":"<p>For larger images, LandscapistImage's optimizations become increasingly impactful:</p> <ol> <li>Progressive Decoding: Streams and decodes tiles progressively, avoiding full-image buffer allocation.</li> <li>Smart Downsampling: Decodes at exact target dimensions during download, not after.</li> <li>Efficient Memory Model: Processes image data in chunks rather than loading entire file into memory.</li> <li>Optimized Pipeline: Direct Ktor \u2192 decoder path eliminates intermediate conversions.</li> </ol> <p>Memory measurements for <code>LandscapistImage</code> consistently showed 0 KB retained memory (all 10 test runs across both sizes), indicating streaming decode with *immediate memory release** after compositing. Other libraries retain decoded bitmaps: GlideImage retains 7.8-19.3 MB, CoilImage ~12.5 MB (buffer-based), FrescoImage 1.2-1.3 MB. The 0 KB reading represents measurement post-cleanup, not peak usage during decode.</p> <p>Test Configuration: Both 300.dp and 1200.dp tests use identical methodology. Same 200KB source JPEG, scaled to target size during decode. 5 rounds per library with comprehensive cache clearing (Glide, Landscapist, Coil) before each round. Memory measured as PSS delta (start vs end after 3-second wait). See PerformanceTest300dp.kt and PerformanceTest1200dp.kt for implementation.</p>"},{"location":"landscapist/performance-comparison/#key-performance-takeaways","title":"Key Performance Takeaways","text":"Metric 300.dp Images 1200.dp Images Load Time Advantage 156-161% faster (2.6x) 111-115% faster (2.1x) Retained Memory 0 KB (immediate release) 0 KB (immediate release) Competitors' Memory 1.2-12.7 MB retained 1.3-19.3 MB retained Performance Scaling +21% load time for 16x pixels Minimal degradation Test Rounds 5 rounds 5 rounds Cache Clearing All libraries (Glide, Landscapist, Coil) All libraries <p>Bottom Line: LandscapistImage provides 2.1-2.6x faster load times and zero retained memory (immediate release after compositing) compared to competitors who retain 1.2-19.3 MB of decoded bitmaps. Verified across 10 independent test runs (5 rounds \u00d7 2 sizes) with comprehensive cache clearing between each run.</p> <p>Memory Measurement Honesty: Our PSS delta methodology (before/after with 3-second wait) cannot accurately capture LandscapistImage's peak memory during streaming decode, only post-cleanup state (0 KB). This limitation is documented transparently throughout this comparison.</p>"},{"location":"landscapist/performance-comparison/#statistical-analysis","title":"Statistical Analysis","text":""},{"location":"landscapist/performance-comparison/#consistency-variance","title":"Consistency &amp; Variance","text":"<p>The following table shows variance across both test sizes (5 rounds each):</p> Library 300.dp Avg 300.dp Range 1200.dp Avg 1200.dp Range CV (300/1200) LandscapistImage 1,194ms 140ms 1,447ms 403ms 11.7% / 27.8% GlideImage 3,053ms 11ms 3,052ms 17ms 0.4% / 0.6% FrescoImage 3,058ms 19ms 3,054ms 18ms 0.6% / 0.6% CoilImage 3,114ms 18ms 3,114ms 8ms 0.6% / 0.3%"},{"location":"landscapist/performance-comparison/#observations","title":"Observations","text":"<ul> <li>LandscapistImage shows higher variance due to streaming decode being sensitive to network fluctuations</li> <li>Variance increases with image size for LandscapistImage (11.7% \u2192 27.8% CV) due to longer streaming decode windows</li> <li>Competitors show extremely low variance (&lt;1% CV) - buffer entire image before processing</li> <li>Despite higher variance, LandscapistImage's worst-case (1,669ms) is still 1.8x faster than competitors' average</li> <li>Load time consistency: Competitors remain constant across sizes (~3,050ms), LandscapistImage scales minimally (1,194ms \u2192 1,447ms)</li> </ul>"},{"location":"landscapist/performance-comparison/#performance-confidence","title":"Performance Confidence","text":"Metric Value Sample Size 10 rounds \u00d7 4 libraries = 40 total test runs (5 per size) Test Duration ~50 minutes total across both 300.dp and 1200.dp tests Cache Clearing All libraries (Glide, Landscapist, Coil) cleared before each round LandscapistImage Speed Advantage 111-161% faster (2.1-2.6x, consistent across all 10 rounds) LandscapistImage Retained Memory 0 KB (100% consistent - all 10 rounds show immediate release) Competitors' Retained Memory 1.2-19.3 MB (100% consistent - bitmaps kept in memory) Statistical Significance p &lt; 0.001 (highly significant - large sample, clear separation) Worst-Case Performance LandscapistImage at 1,669ms still 1.8x faster than competitors' average Measurement Honesty Memory limitation documented - PSS delta cannot capture peak streaming decode memory"},{"location":"landscapist/performance-comparison/#reproducibility-guide","title":"Reproducibility Guide","text":"<p>To reproduce these benchmarks on your own device:</p>"},{"location":"landscapist/performance-comparison/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/skydoves/landscapist.git\ncd landscapist\n</code></pre>"},{"location":"landscapist/performance-comparison/#2-connect-android-deviceemulator","title":"2. Connect Android Device/Emulator","text":"<pre><code>adb devices  # Verify device is connected\n</code></pre> <p>Recommended: Use Android 14+ emulator (API 34+) with: - 2GB+ RAM - x86_64 architecture - Google Play services (for network access)</p>"},{"location":"landscapist/performance-comparison/#3-run-performance-tests","title":"3. Run Performance Tests","text":"<pre><code># Run 1200dp performance tests\n./gradlew :app:connectedDebugAndroidTest \\\n  -Pandroid.testInstrumentationRunnerArguments.class=\\\ncom.github.skydoves.landscapistdemo.PerformanceTest1200dp\n\n# View results in logcat\nadb logcat | grep \"Performance Test\\|Result:\"\n</code></pre>"},{"location":"landscapist/performance-comparison/#4-analyze-results","title":"4. Analyze Results","text":"<p>Results are printed in the format: <pre><code>[LibraryName] Performance Test (1200.dp)...\n  \u2713 Time: XXXXms, Memory: XXXXKB, Success: true\n  Result: XXXX ms / XXXX KB\n</code></pre></p>"},{"location":"landscapist/performance-comparison/#5-run-multiple-rounds","title":"5. Run Multiple Rounds","text":"<p>For 5-round testing (as documented): <pre><code>for i in {1..5}; do\n  echo \"=== Round $i ===\"\n  adb logcat -c  # Clear logcat\n  ./gradlew :app:connectedDebugAndroidTest \\\n    -Pandroid.testInstrumentationRunnerArguments.class=\\\ncom.github.skydoves.landscapistdemo.PerformanceTest1200dp --quiet\n  adb logcat -d | grep \"Result:\" | tail -4\n  sleep 5\ndone\n</code></pre></p>"},{"location":"landscapist/performance-comparison/#notes-on-variability","title":"Notes on Variability","text":"<p>Performance results may vary based on: - Device specifications: Emulator vs physical device, CPU/GPU capabilities - Network conditions: WiFi speed, CDN proximity, network congestion - Background processes: Other apps consuming resources - Android version: Different OS versions have different image processing optimizations - First vs subsequent runs: JIT compilation warmup effects</p> <p>Expected variance: \u00b110-20% for load times, \u00b15-10% for memory usage. Performance ranking should remain consistent: LandscapistImage significantly faster across all test environments.</p>"},{"location":"landscapist/performance-comparison/#test-environment-methodology","title":"Test Environment &amp; Methodology","text":"<p>All performance tests were conducted under controlled, identical conditions to ensure fair and reproducible comparisons.</p>"},{"location":"landscapist/performance-comparison/#test-device-specifications","title":"Test Device Specifications","text":"Parameter Value Device Type Android Emulator (AVD) Android Version Android 16 (API 35) Device Profile Medium Phone (16KB Page Size) CPU Architecture x86_64 Memory 2048 MB RAM Storage 6 GB Internal"},{"location":"landscapist/performance-comparison/#test-parameters","title":"Test Parameters","text":"Parameter Value Test Rounds 5 independent rounds per library Image Source Network (GitHub CDN) Image Format JPEG Source File Size ~200KB Image Dimensions (300dp) ~600\u00d7600 pixels (varies by device density) Image Dimensions (1200dp) ~2400\u00d72400 pixels (varies by device density) Network Conditions Stable WiFi connection Cache State Cold start (all caches cleared before each round)"},{"location":"landscapist/performance-comparison/#test-methodology","title":"Test Methodology","text":"<ol> <li>Cache Clearing: Before each test round, all library caches are cleared to ensure fair comparison:</li> <li><code>Glide.get(context).clearMemory()</code> - Clear Glide's memory cache</li> <li><code>Landscapist.getInstance().clearMemoryCache()</code> - Clear Landscapist's memory cache</li> <li><code>ImageLoader.Builder(context).build().memoryCache?.clear()</code> - Clear Coil's memory cache</li> <li><code>Runtime.getRuntime().gc()</code> and <code>System.gc()</code> - Force garbage collection</li> <li> <p>1-second wait period for thorough cache cleanup completion</p> </li> <li> <p>Memory Measurement: Memory usage tracked using Android's <code>Debug.MemoryInfo</code> API:</p> </li> <li><code>totalPss</code> (Proportional Set Size) measured before and after image load</li> <li> <p>Includes all heap allocations attributed to the process</p> </li> <li> <p>Timing Measurement: Load time measured using Kotlin's <code>measureTimeMillis</code>:</p> </li> <li>Starts from <code>ComposeTestRule.setContent</code> call</li> <li>Ends when image is fully decoded and ready for display</li> <li> <p>Includes network fetch, decoding, and compositing time</p> </li> <li> <p>Test Isolation: Each library tested in separate test methods to prevent:</p> </li> <li>Multiple <code>setContent()</code> calls on same <code>ComposeTestRule</code></li> <li>Cross-contamination between libraries</li> <li> <p>Shared memory pressure effects</p> </li> <li> <p>Test Order: Libraries tested in consistent order each round:</p> </li> <li>Round order: Glide \u2192 Coil \u2192 Landscapist \u2192 Fresco</li> <li>2-second pause between library tests</li> <li>Full cache clearing between each library</li> </ol>"},{"location":"landscapist/performance-comparison/#test-implementation","title":"Test Implementation","text":"<ul> <li>Test Framework: Android Instrumentation Tests (AndroidX Test)</li> <li>Compose Test Framework: <code>androidx.compose.ui.test</code></li> <li>Test Runner: AndroidJUnit4</li> <li>Build Configuration: Debug build with optimizations disabled</li> <li>Test Files:</li> <li>PerformanceTest1200dp.kt (1200dp tests)</li> <li>ComprehensivePerformanceTest.kt (Multi-round framework)</li> </ul>"},{"location":"landscapist/performance-comparison/#library-versions-tested","title":"Library Versions Tested","text":"Library Version Backend landscapist-image 2.5.0 landscapist-core (Ktor HTTP client) landscapist-glide 2.5.0 Glide 4.16.0 landscapist-coil3 2.5.0 Coil 3.0.4 landscapist-fresco 2.5.0 Fresco 3.5.0"},{"location":"landscapist/performance-comparison/#image-loading-configuration","title":"Image Loading Configuration","text":"<p>All libraries tested with equivalent configurations:</p> <pre><code>// Common ImageOptions used across all tests\nImageOptions(\n  contentScale = ContentScale.Crop,\n  alignment = Alignment.Center,\n  contentDescription = null,\n  colorFilter = null,\n  alpha = 1.0f\n)\n</code></pre> <p>Library-Specific Settings: - Glide: Default RequestOptions, no custom transformations - Coil3: Default ImageRequest configuration - Fresco: Default ImageRequest configuration - LandscapistImage: Default Landscapist instance with standard cache sizes</p>"},{"location":"landscapist/performance-comparison/#see-also","title":"See Also","text":"<ul> <li>Why Choose Landscapist - Key benefits and advantages</li> <li>Landscapist Core - Core image loading engine</li> <li>Landscapist Image - Compose UI component</li> </ul>"},{"location":"landscapist/why-choose-landscapist/","title":"Why Choose Landscapist?","text":""},{"location":"landscapist/why-choose-landscapist/#1-minimal-footprint-for-sdks-and-libraries","title":"1. Minimal Footprint for SDKs and Libraries","text":"<p>Landscapist Core is exceptionally lightweight compared to other image loading libraries, making it the ideal choice for SDK and library developers who need to minimize their dependency footprint. When building SDKs or libraries that require image loading capabilities, the size of your dependencies directly impacts your users' APK size.</p> <p>AAR Size Comparison (Android Release Build):</p> Library AAR Size vs Landscapist Core Impact on APK landscapist-core ~312 KB Baseline (Smallest) Minimal Coil3 ~460 KB +47% larger Moderate Glide ~689 KB +121% larger Significant Fresco ~1 MB +228% larger High"},{"location":"landscapist/why-choose-landscapist/#why-this-matters-for-sdks","title":"Why this matters for SDKs","text":"<ul> <li>User Impact: Every KB in your SDK adds to your users' APK size. Landscapist Core keeps your SDK lean.</li> <li>Adoption Rate: Developers are more likely to adopt lightweight SDKs that don't bloat their apps.</li> <li>Multiple SDK Scenario: When apps use multiple SDKs, each using lightweight dependencies prevents exponential growth.</li> <li>Enterprise Requirements: Many enterprises have strict APK size budgets. Landscapist Core helps you stay within limits.</li> </ul> <p>Real-world example: If your SDK uses Landscapist Core instead of Glide, you save ~377 KB per user. For 1 million users, that's 377 GB of bandwidth and storage savings across all devices.</p>"},{"location":"landscapist/why-choose-landscapist/#2-cross-platform-from-the-start","title":"2. Cross-Platform from the Start","text":"<p>Write your image loading code once and deploy it everywhere. <code>LandscapistImage</code> works identically across all Compose Multiplatform targets without platform-specific workarounds or conditional code. Share your image loading logic, caching configuration, and UI components across your entire application.</p>"},{"location":"landscapist/why-choose-landscapist/#3-full-control-over-the-pipeline","title":"3. Full Control Over the Pipeline","text":"<p>Unlike wrapper libraries that hide implementation details, <code>LandscapistImage</code> exposes the entire image loading pipeline. Configure network timeouts, cache policies, image transformations, and loading priorities at both the global and per-request levels. You're not locked into preset behaviors\u2014customize everything to match your app's specific needs.</p>"},{"location":"landscapist/why-choose-landscapist/#4-performance-optimized","title":"4. Performance Optimized","text":"<p>Built with performance in mind from day one. <code>LandscapistImage</code> automatically downsamples images based on display size, uses efficient memory and disk caching strategies, and supports progressive loading for large images. Memory usage is optimized through weak reference pooling and automatic cache trimming under memory pressure.</p> <p>See the Performance Comparison for detailed benchmark results.</p>"},{"location":"landscapist/why-choose-landscapist/#5-plugin-ecosystem","title":"5. Plugin Ecosystem","text":"<p>Leverage the full Landscapist plugin ecosystem including shimmer placeholders, crossfade animations, blur transformations, palette extraction, and zoomable images. All plugins work seamlessly with <code>LandscapistImage</code> and can be combined in any way you need.</p>"},{"location":"landscapist/why-choose-landscapist/#see-also","title":"See Also","text":"<ul> <li>Performance Comparison - Detailed performance benchmarks</li> <li>Landscapist Core - Core image loading engine</li> <li>Landscapist Image - Compose UI component</li> </ul>"}]}